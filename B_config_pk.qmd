# Configurar un paquete R {#package-setup}

```{r setup, include=FALSE}
# TODO: Have this as its own setup chunk?
library(usethis)
```

## Objetivos de aprendizaje

- Identificar cuándo y por qué crear un paquete R.
- Conocer y utilizar los paquetes R `{devtools}` y `{usethis}` a
  automatizar y agilizar muchas tareas de desarrollo de paquetes.
- Aprende a crear un nuevo paquete R utilizando
  `usethis::create_package()`.
- Describe y explica la finalidad de las carpetas y archivos de un
  paquete esqueleto de R.
- Describe qué son los valores predeterminados globales en R y cómo utilizarlos para hacer
  el desarrollo de paquetes.
- Aprender cómo y por qué puedes añadir datos a un paquete de R.

## ¿Por qué crear un paquete R?

El objetivo principal del desarrollo de software es simplificar alguna tarea o un conjunto de
tareas para ti y para los demás (como tu equipo, si lo tienes).
Esto también se aplica al desarrollo de software en R. Crear un paquete R
es una de las formas más potentes de simplificar tareas, independientemente de lo
sencillas o complejas.

A lo largo de este libro mostraremos que crear y desarrollar un programa R
no es tan difícil como podría parecer a primera vista. Pero antes de hacer un
paquete, hay que pensar en algunas cosas. Por ejemplo, ¿cómo
determinar si debes hacer un paquete R? Hazte estas preguntas
ti mismo. ¿Has creado alguna vez una función, por sencilla que sea? ¿Has
utilizado esa función más de una vez en más de un proyecto o
proyecto o archivo, ya sea copiándola y pegándola o utilizando el archivo que
que la contiene? Si has respondido afirmativamente a estas dos preguntas, entonces deberías
crear un paquete R para esa función. Pero puede que te preguntes, ¿por qué hacer un
paquete con una sola función? Porque nunca se acaba con *sólo* una
función, es muy probable que ganes más en tu trabajo. Aparte de
empaquetar las funciones de R, si tienes conjuntos de datos pequeños o medianos
que utilizas en varios proyectos o archivos, puedes incluso empaquetar
los datos.

Aparte del "sí" a estas preguntas, hacer un paquete de R ahora es mucho
más fácil que en el pasado. Esto se debe en gran parte a paquetes de R como
`{devtools}` y `{usethis}` que están diseñados para simplificar el desarrollo de R
paquetes. Además de estos paquetes, también hay muchos gratuitos,
libros y recursos en Internet para aprender a crear paquetes R y hacer
desarrollo de software en R (ver @recursossec).

Si volvemos al panorama general del prefacio de la Sección
@sec-big-picture, crear un paquete R, ya sea publicado en GitHub o en
enviado a CRAN, que esté relacionado con un trabajo científico específico
proyecto o análisis suele cumplir los requisitos de reproducibilidad y de
de la investigación. Esto se debe a que hacer un paquete de R
suele requerir un mayor nivel de rigor, pruebas, documentación y
inspección del código, lo que significa que tú y los demás podéis confiar más en
en los resultados. Y si está en GitHub, es mucho más fácil compartir tu trabajo.
con otros y tener un mayor impacto en la investigación en general.

## ¿Qué es un paquete R?

Para entender qué es un paquete R, daremos un paso atrás y consideraremos
lo que ocurre cuando interactuamos con R. El uso muy básico y de bajo nivel de R
es a través de la Consola de R, donde escribes funciones en R para realizar tareas que
que se imprimen en la pantalla. Esta Consola de R inicial funciona en la pantalla de tu ordenador.
de tu ordenador, normalmente algo parecido a `/home/username/`
en Linux, `/Users/username/` para macOS, o `C:\Users\username` para
Windows. Así que cualquier dato o gráfico que guardes o importes debe incluir
la ruta del archivo a la ubicación correcta. Desde un punto de vista reproducible y modular
modular, esto va en contra de las buenas prácticas. Asimismo, el código R
introducido en esta sesión mientras está en la Consola no es
 guardado [^03-paquete-configuración-1] Por tanto, no puedes reutilizar o compartir fácilmente el código de R
cuando se utiliza de esta forma.

[^03-paquete-instalación-1]: Bueno, técnicamente puedes ver el historial mediante
por defecto en un archivo, pero esto almacena *todo* lo que has introducido en
la consola de R, incluido el código incorrecto.

<!-- TODO: ¿Imagen aquí que describa esto un poco más? -->

El siguiente nivel es guardar el código en un script R (un archivo almacenado en cualquier lugar
en el ordenador que termina en `.R`) y hacer que R ejecute este código en
secuencia. En el pasado, la gente podía escribir scripts de R en editores de texto como
vim, emacs o Notepad, y ejecutar manualmente el script en la consola de R.
En la actualidad, la mayoría de la gente utiliza un Editor de Desarrollo Integrado (IDE).
de Desarrollo Integrado (IDE) (REF LINK) como RStudio. Este
es el método más utilizado para realizar cualquier tipo de trabajo en R.
Teóricamente, el código escrito de esta forma es reproducible y se puede
compartido. Sin embargo, en la práctica, a menudo el código R de estos archivos se escribe
de secuencia, ya que los investigadores trabajan con R de forma más interactiva que
programáticamente. Y el directorio de trabajo (REF LINK) de un script R
cambia en función de cómo se utilice, por lo que seguimos encontrando similares
como si utilizáramos la Consola R por sí sola. Puedes utilizar trucos ingeniosos
para almacenar código o funciones R de uso común en un script R y `source()`
estos archivos desde otros scripts, entre otros muchos trucos. En esencia,
esto implica hacer un seguimiento de los archivos R en todo tu ordenador para poder
hacer tu trabajo.

Un paquete R no es muy diferente de utilizar varios scripts R. En
hay ciertas expectativas y convenciones que deben seguirse para
para que se "instale" en tu ordenador como paquete R. Algunas de estas
convenciones son:

- Debe haber un archivo llamado `DESCRIPTION` que contiene metadatos
  necesarios para que R sepa cómo instalar el paquete. Veremos qué
  deben tener los campos en la Sección @sec-crear-un-paquete.

- Debe haber un `R/` carpeta. Normalmente sólo contendrá `.R`
  y normalmente sólo contendrá las funciones R que hayas creado. Nosotros
  cubrimos las funciones con más detalle `@sec-function-development`.

- Debe haber un `NAMESPACE` que contenga la lista de funciones
  de tu paquete que quieres que utilice el usuario. No cubriremos este
  en detalle porque gran parte de este archivo se gestiona automáticamente
  con la función `{devtools}` y `{roxygen2}` paquetes.

- La carpeta con el código R debería llamarse, aunque no tiene por qué, así
  igual que el nombre del paquete. Por ejemplo, el paquete R
  `{usethis}` tiene el nombre de carpeta `usethis/`. Esto no es un
  requisito explícito, pero es muy recomendable. R determina la
  nombre del paquete a partir del `Package:` del campo `DESCRIPTION`
  archivo.

Nada de esto es algo de lo que tengas que preocuparte realmente porque el
paquetes `{usethis}` y `{devtools}` están diseñados para hacer muchas de estas
tareas de configuración de paquetes por ti, o al menos para simplificarlas.

¿Cómo funciona la instalación de paquetes? Cuando le dices a R que instale un
paquete, que es un conjunto de archivos y carpetas que siguen un
convención específica, R toma la carpeta y la convierte en su propia
especial. Luego R guarda este formato especial en una ubicación por defecto que es
específica del sistema operativo, como macOS, Windows o Linux. Para ver
dónde están instalados los paquetes, utiliza

```{r}
.libPaths()
```

Si escribes esto en tu Consola, lo que verás probablemente será un
un poco diferente a esto. Si `.libPaths()` muestra más de una ruta,
normalmente la primera contendrá todos los paquetes. Utilicemos la función `{fs}`
para explorar esta carpeta. En primer lugar, veamos *algunos* de los paquetes
que se instalan utilizando `dir_ls()`.

```{r}
library(fs)
# R prioritizes the first path, so we'll select it
primary_library_path <- .libPaths()[1]
packages <- dir_ls(path(primary_library_path))

# Number of installed packages
length(packages)
# See the first few package names
head(packages)
```

Si queremos ver cómo almacena R los paquetes en su formato especial, podemos
utilizar `dir_tree()` y mirar dentro del paquete instalado `fs/` instalada.

```{r}
dir_tree(path(primary_library_path, "fs"))
```

Consulta el `R/fs.rdb` y `R/fs.rdx` ¿archivos? Son los formatos especiales
que contienen las funciones dentro de `{fs}` que R buscará cuando
carga el `{fs}` paquete. Cuando se instala un paquete en R, lo que ese
significa que se encuentra en la carpeta de la biblioteca de R dada por `.libPaths()` con
los archivos en el formato específico de R. Así que cuando ejecutes `library(fs)`, R
sabrá que debe buscar las funciones que se encuentran en el archivo `fs/` carpeta del paquete.

Por tanto, instalar tu propio paquete que sólo se encuentra en tu ordenador es
no difiere de instalar un paquete de CRAN con
`install.packages()` o desde GitHub con `pak::pak()`. El único
diferencia es que los paquetes en CRAN o GitHub (de un repositorio público)
pueden ser utilizados por cualquiera que tenga acceso a Internet.

Te habrás dado cuenta de que hemos utilizado la sintaxis
`packagename::functionname()` unas cuantas veces. Esto le dice a R que haga
es que utilice la función de un paquete concreto. Así que `pak::pak()` es
decirle a R que utilice la función `pak()` de la función `{pak}` paquete. En
desarrollo de paquetes en particular, utilizamos esto en lugar de, para
ejemplo, `library(pak)` porque queremos ser explícitos sobre qué
función queremos utilizar y porque no necesitamos cargar todas las
funciones del paquete cuando sólo queremos utilizar una o dos.

### Ejercicio: Instalar un paquete desde GitHub {#ex-install-github-package}

Como hacemos un uso intensivo de `{usethis}` para crear paquetes R, vamos a
familiarizarnos un poco con él. Abre el programa [repositorio GitHub de
`{usethis}`](https://github.com/r-lib/usethis) y completa estas tareas.

1. Encuentra qué archivo contiene el `create_package()` función
  [`R/`](https://github.com/r-lib/usethis/tree/main/R) carpeta. Sugerencia,
  utiliza la función "Buscar o saltar a..." de GitHub para encontrar cosas en la carpeta
  repositorio.

2. Averigua dónde está el nombre del paquete en el `DESCRIPTION` archivo.

3. En la consola de RStudio, utiliza `pak::pak()` para instalar el archivo `{usethis}`
  paquete. Consulta la documentación de ayuda (`?pak::pak`) para saber cómo
  utilizarla para instalar el paquete.

## Crear un paquete

Ahora que hemos determinado que *instalado* R instalados se encuentran en
ubicación de la biblioteca determinada por `.libPaths()` ¿qué pasa con los paquetes que
estás desarrollando activamente? ¿Los guardas en la misma ubicación?
Respuesta corta: no, no deberías. En lugar de eso, crea, desarrolla y guarda tus
archivos en algún lugar de tu carpeta Documentos, o en algún lugar donde guardes
otros proyectos de trabajo. Dónde los guardes exactamente depende de ti, pero como
ejemplo, podríamos hacerlos en `Documents/R/` o ... TODO: Añadir más
ubicaciones potenciales aquí.

Decidir dónde guardar tu paquete es la parte fácil. La parte difícil
viene con *poner nombre a* tu paquete. Crear un nombre significativo, pegadizo y
que se pueda buscar en Google es *realmente difícil*. No hay forma fácil de enseñar
cómo hacer uno y a menudo requiere varios días de lluvia de ideas
ideas. Una vez que tengas una idea, querrás asegurarte de que no ha
ya ha sido tomada. Puedes hacerlo fácilmente con el paquete
`{available}`. Ya hemos descrito en el prefacio (Sección
@ref(resumen-paquetes-creados)) que vamos a crear un paquete
llamado `{zipfs}` comprobemos si el nombre del paquete es
`{available}`. El resultado se parecerá un poco a esto, aunque verás
más elementos.

```{r cs-available-pkg, eval=FALSE}
available::available("zipfs")
```

```{r ce-available-pkg, eval=TRUE, echo=FALSE}
available::valid_package_name("zipfs")
available::available_on_cran("zipfs")
available::available_on_bioc("zipfs")
available::available_on_github("zipfs")
```

<!-- TODO: Actualizar en función de si zipfs se ha añadido a GitHub -->

En este caso vemos que `{zipfs}` está disponible para que lo utilicemos. Ahora que
tenemos un nombre, el siguiente paso es configurar la infraestructura básica para
el paquete. Afortunadamente, el `{usethis}` paquete ayuda a facilitar muchas de las
dificultad de este paso. Cuando utilizamos el paquete `usethis::create_package()`
se configurarán los archivos y carpetas básicos que necesitamos para que
R lo instale como paquete. Utilizaremos esta función para crear un
`{zipfs}` paquete.

TODO: Establece el autor dentro de Acciones GH con la opción usethis.nombre\_completo. Utiliza
local .Rprofile, activa el cambio con una variable env incluida en el
acción?

```{r cs-create-pkg, eval=FALSE}
usethis::create_package(path = "zipfs")
```

```{r admin-create-pkg}
#| echo: false
temp_dir <- fs::path_temp()
project_path <- fs::path(temp_dir, "zipfs")
withr::with_dir(
  new = temp_dir,
  {usethis::create_package(path = "zipfs", open = FALSE, rstudio = TRUE)}
)
usethis::proj_set()
warning(usethis::proj_get())
```

En lugar de utilizar código, también puedes hacerlo a través de RStudio (si utilizas
lo) haciendo clic a través de "Archivo -> Nuevo Proyecto -> ... TODO: Completar".
Sin embargo, cuando ejecutes este código en la Consola, aparecerá un montón de texto
(como arriba) indicando lo que se ha hecho en tu ordenador. Vamos a
cada una de las cosas que se han creado a lo largo del resto de
esta sección.

::: nota de llamada

<!-- TODO: Asegúrate de que esto funciona para css y latex -->

Puedes observar que estamos creando el paquete en el directorio temporal
temporal "`r fs::path_dir(project_path)`". Porque (casi) todos los paquetes
salida del código de este libro se genera automáticamente, necesitamos
tener una forma de crear el paquete y hacer otros trabajos basados en código que funcionen
en cada uno de los ordenadores de los autores, así como en las Acciones GitHub
(que construye la versión final de este sitio web). Así que optamos por
utilizar la ubicación temporal proporcionada por el `tempdir()` de R. La dirección
nombre de esta carpeta temporal es aleatorio, por lo que si la utilizas también, te
verás algo diferente de lo que aparece en el libro.
:::

Como escribimos en la sección anterior, todos los paquetes de R deben tener al menos
un `R/` carpeta `DESCRIPTION` archivo y un `NAMESPACE` archivo. Dentro de nuestra
paquete recién creado, podemos ver que se han creado todos ellos. En
además de los archivos y la carpeta necesarios, también están los `.Rproj`
ya que utilizamos RStudio, el archivo `.gitignore` ya que utilizaremos
utilizaremos Git, y un `.Rbuildignore` que le diga a R que ignore
ciertos archivos al construir el paquete. Esto se convertirá en
importante más adelante.

```{r admin-new-pkg-file-tree}
#| echo: false
usethis::with_project(
  path = project_path,
  {fs::dir_tree(all = TRUE)},
  quiet = TRUE
)
```

Abre el `DESCRIPTION` para que podamos ver su interior:

```{r admin-show-desc}
#| echo: false
usethis::with_project(
  path = project_path,
  {desc::desc()},
  quiet = TRUE
)
```

Como ya hemos dicho, el archivo `DESCRIPTION` contiene los metadatos de
y algunos ajustes de configuración que R utiliza cuando construye y
instalarlo. El formato de los metadatos utiliza el patrón `key: value`.
Así, por ejemplo, la clave `Package` tiene el valor `zipfs` que indica a R
cuál es el nombre del paquete. De la misma forma, `Title` y `Authors` dan un
un poco más de información sobre lo que hace el paquete y quién lo creó. En
hay muchas más claves que cubrir, algunas de las cuales no es importante aprender
ya que se crean automáticamente y R las utiliza internamente para
la construcción en general. Pero algunas son bastante importantes. Concretamente,
el `Title`, `Authors` y `Description` deben tener más
valores adecuados.

### Ejercicio: Añade detalles al `DESCRIPTION` archivo {#ex-fill-in-description}

Rellenemos los campos clave importantes en el archivo `DESCRIPTION` con
mejores detalles. Si no has abierto el `DESCRIPTION` archivo, por favor
ábrelo.

1. En el `Title:` sustituye el texto genérico actual por
  con `Testing Zipfs Law on Novels`. Ten en cuenta las instrucciones para utilizar un
  línea y que la primera letra de cada palabra esté en mayúscula.

2. Para la `Authors@R:` campo de valor, ve a la Consola R y escribe
  y ejecuta `?person`. Lee la documentación de ayuda y luego
  rellénala lo mejor que puedas en el `Authors@R:` sección El inicio
  debe ser como `Authors@R: person(`. Para el `role` argumento
  tendrás que añadir `c("cre", "aut")`. Lee qué significan en
  la página `?person` documentación de ayuda. TODO: Puede que no todo el mundo tenga esto
  clave de autor. Algunos pueden tener `Authors:` o `Maintainer:` necesitar
  considerar cómo manejar esto.

3. En la `Description:` campo de valor, sustituye el texto genérico actual
  por una breve explicación (una o dos frases)

TODO: ¿Esto debería ser una solución tal vez? En `DESCRIPTION` archivo debería
tener este aspecto:

```{r ee-fill-in-description, include=FALSE}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
desc_file <- fs::path(project_path, "DESCRIPTION")
desc <- desc::description$new(file = desc_file)
desc$set(
    Title = "Testing Zipfs Law on Novels",
    Description = "Contains functions to test out whether Zipfs Law applies to multiple novels."
)
# TODO: Decide on name of author to use through
desc$add_author(
    given = "Sami",
    email = "sami@random.com",
    role = c("aut", "cre")
)
desc$write()
```

```{r sol-fill-in-description}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book
desc
```

## Configuración de R para desarrolladores

Te habrás dado cuenta de la frecuencia con la que utilizamos `::` cuando nos referimos a funciones
dentro de los paquetes. Probablemente también te habrá parecido un poco
molesto tener que teclearlas siempre, sobre todo de forma interactiva en
la consola de R. Utilizaremos funciones del `{usethis}` y
`{devtools}` mucho como desarrolladores de paquetes R y para el trabajo de RSE, así que para hacer
nuestro flujo de trabajo, `{usethis}` naturalmente tiene funciones para ayudarnos.
En la consola de R, ejecuta cada uno de estos comandos, siguiendo sus
instrucciones antes de ejecutar el siguiente.

<!-- TODO: ¿Incluir la salida de éstos? -->

```{r cs-developer-profile-options, eval=FALSE}
usethis::use_devtools()
usethis::use_usethis()
```

No olvides reiniciar tu sesión, utilizando "Ctrl-Shift-F10" o "Sesión
\-> Reiniciar R" o utilizando la "Paleta de comandos" ("Ctrl-Shift-P" y
escribe "Reiniciar R") mientras utilizas RStudio. Después de reiniciar la sesión de R,
comprueba que el `{usethis}` y `{devtools}` son cargados por
tecleando `use_` en la consola de R y pulsando la tecla TAB para listar
funciones disponibles.

<!-- TODO: Añade detalles sobre cómo solucionar problemas si lo anterior no funciona. -->

Después, queremos configurar nuestro RStudio para que cada vez que abramos el programa R
de nuestro `{zipfs}` paquete, la sesión R se inicie en "blanco
en blanco". Lo que esto significa es que no queremos datos antiguos, funciones o
variables cargadas en el Entorno desde la sesión anterior que podríamos
haber trabajado.

```r
use_blank_slate()
```

Esta función ajusta las opciones a las Opciones Globales del usuario en RStudio. Si
quieres estas opciones a nivel de proyecto, como el paquete, para que cuando
colabores con otros, todos utilicen la misma configuración, utiliza
en su lugar:

```{r cs-blank-slate-project, eval=FALSE}
use_blank_slate("project")
```

```{r ce-blank-slate-project, echo=FALSE}
# If needed. Code used in section, NOT shown to learners, but needed for auto building of package/book
usethis::with_project(
  path = project_path, 
  {usethis::use_blank_slate()},
  quiet = TRUE
)
```

### Ejercicio: Establecer configuraciones adicionales

<!-- TODO: ¿Debería ser una sección de notas, un apéndice o un ejercicio? -->

Hay otras configuraciones que puedes establecer para que tu trabajo sea un
desarrollador, sobre todo cuando añadas cosas a tu `.Rprofile`
archivo. Consulta el [utilizar este
viñeta](https://usethis.r-lib.org/articles/usethis-setup.html) para
más detalles al respecto.

Abre tu `.Rprofile` utilizando `edit_r_profile()`. Dentro, copia y
pega el texto siguiente y sustituye el `___` por tus valores específicos. Si
necesitas ayuda para saber qué rellenar en el campo `person()` sección
utiliza `?person` para leer la documentación de ayuda. El último valor
sobre la `Roxygen` y `markdown = TRUE` se tratará más en el
`@sec-function-development` y en la documentación del paquete @sec.

```r
options(
    usethis.full_name = "___",
    usethis.description = list(`Authors@R` = 'person(
      given = "___", 
      family = "___", 
      email = "___", 
      role = c("aut", "cre"))',
      Roxygen = "list(markdown = TRUE)"
    )
)
```

## Flujo de trabajo de desarrollo de paquetes

Aunque hay varias formas de desarrollar un paquete R, una
un flujo de trabajo bien establecido y documentado gira en torno a
uso de `{usethis}` y `{devtools}`. Este es el flujo de trabajo que estamos
en este libro y que repasaremos brevemente en esta sección.
A lo largo de este libro utilizarás este flujo de trabajo muchas veces, así que
obtendrás mucha práctica con él.

Los pasos típicos utilizados en este flujo de trabajo de desarrollo son, de forma sencilla
así:

1. Cuando tienes una idea para una función o conjunto de funciones similares, para
  ejemplo, para cargar archivos de texto, pasarías a la Consola y
  teclear `use_r("load-text")`. Se creará un nuevo archivo R en la carpeta
  `R/` y se abrirá en RStudio.

2. En este nuevo archivo empezarías a crear y desarrollar el
  función, escribiendo los argumentos de entrada y la eventual salida, mientras que
  empezando a rellenar la documentación de Roxygen. Hablaremos de una forma más
  detallado del flujo de trabajo de una función en capítulos posteriores, como
  `@sec-function-development`.

3. Una vez que consideres que la función está lista para ser probada, podrías probar
  la función ejecutándola en el `@examples` Roxygen
  o utilizando un script temporal de "desarrollo" o R Markdown
  o dentro de una de las viñetas de R Markdown, todas las cuales
  hablaremos más en `@sec-function-development`. Para hacer el
  en R, utilizarás `Ctrl-Shift-L` mientras que en
  RStudio para ejecutar `load_all()` (desde `{devtools}`). Después de `load_all()`
  termine, ejecuta la función para ver si funciona.

4. A no ser que la función que hayas creado sea muy sencilla o esté en la categoría *muy*
  improbable que escribieras un código que funcionara
  perfectamente la primera vez, lo más probable es que la función no funcione
  exactamente como querías o dé un error. En ese caso, harías
  a la función y seguir desarrollándola, alternando
  entre desarrollarla, ejecutar `load_all()` y probar la función
  función.

Vamos a probar un poco este flujo de trabajo haciendo una práctica temporal
temporal. En la Consola, escribe esta función:

```{r cs-test-workflow, eval=FALSE}
use_r("test-workflow")
```

Cuando se abra, copia y pega la función simple que aparece a continuación en el campo
recién creada `R/test-workflow.R` recién creado:

```{r cs-temp-function}
greeting <- function(name = "Sami") {
    paste0("Hi there, ", name, "!")
}
```

Antes de hacer nada, escribe `greeting()` en la consola y pulsa
intro para ejecutarlo. ¿Qué ocurre? Nada. Eso es porque R no sabe
la función. Tenemos que hacer que R la conozca mediante
ejecutando la función directamente en R desde el script (`Ctrl-Enter` en
enviar a la Consola), utilizando `source()` en el script, instalando
el paquete, o imitando la instalación del paquete (pero no realmente
instalarlo) con la función `load_all()` función Como estamos haciendo paquete
*desarrollo* utilizaremos el `load_all()` función, convenientemente delimitada
a las teclas `Ctrl-Shift-L` en RStudio.

Probemos el `load_all()` pulsando `Ctrl-Shift-L`.
Cuando termine de cargarse, vuelve a escribir `greeting()` en la Consola.
Ahora deberías ver que funciona.

### Ejercicio: Practica un poco más el flujo de trabajo {#ex-practice-workflow-load-all}

Puesto que utilizarás mucho este flujo de trabajo al crear paquetes de R, vamos a
haremos algunas prácticas más utilizándolo para que te sientas más cómodo con él.

Realiza los siguientes cambios en la función. Con cada cambio, vuelve a cargar
(`Ctrl-Shift-L` en RStudio o `load_all()` en la consola) para que
funciones actualizadas estén disponibles para R. Después de cada recarga, cambia a
la Consola y ejecuta el comando `greeting()` función.

- Cambia el valor por defecto de `name` argumento de `"Sami"` a
  `"Jun"`.

- Cambia el saludo dentro del `paste0()` de
  `"Hi there, "` a `"How do you do, "`.

- Cambia la función `paste0()` a `paste()`. ¿Qué cambia?

Después de completar estas tareas, como no necesitamos el
`R/test-workflow.R` archivo, lo eliminaremos manualmente o mediante
escribiendo:

```{r delete-test-workflow, eval=FALSE}
fs::file_delete("R/test-workflow.R")
```

## Instalar en lugar de cargar

Cuando desarrolles activamente un paquete, en lugar de utilizarlo directamente en
otro proyecto, utilizamos `load_all()`. Esto se debe a que puede
crear un entorno que imite cómo se comportaría el paquete si estuviera
instalado, sin tener que tomarse el tiempo de instalarlo realmente.

Cuando queramos instalar realmente el paquete, utilizaremos la función `{devtools}`
función `install()` (la combinación de teclas es `Ctrl-Shift-B` para "construir"), que
pone el paquete a disposición de R en tu ordenador. Cuando lo instales,
acceder a las funciones del paquete se hace como lo harías normalmente
con otros paquetes, como cargarlo con `library()`.

No cubriremos esto mucho más en este capítulo, pero por ahora, pruébalo
pulsando el botón `Ctrl-Shift-B` . Observa cuánto tarda
en comparación con `load_all()` (aunque sólo sean unos segundos) y que la tecla R
se reinicie, seguido de una llamada a `library()`.

## Agrupar datos en un paquete

Aunque puedes agrupar datos dentro de un paquete, la gran mayoría de
paquetes de R no contienen datos. En algunos casos, especialmente dentro de
entornos empresariales o académicos personalizados, empaquetar datos en un paquete R
puede hacer que sea muy fácil compartir datos con colegas. Y teniendo en cuenta que R
y muchos paquetes R están diseñados en torno al trabajo con datos de alguna manera,
como utilizar estadísticas o hacer gráficos, también agruparemos datos con nuestros
paquete para poder utilizar los datos en las funciones que vamos a
crearemos a lo largo de este libro.

### A partir de los datos brutos

Puesto que la Ley de Zipf trata de unas matemáticas subyacentes al texto, los "datos" que vamos a
con los que vamos a trabajar son textos de libros. Los libros que vamos a utilizar proceden de
del código abierto [Proyecto Gutenberg](https://www.gutenberg.org/).
Parte de la creación de un paquete R consiste en hacer que la analítica o los datos
reproducibles y explícitos, así que en este sentido, ya que
no tenemos los libros que necesitamos en nuestros ordenadores, tenemos que escribir
pasos de codificación para conseguirlos. Esto es lo que hace el `data-raw/` carpeta
dentro de un paquete R. Dentro de esta carpeta incluimos los scripts de R que tienen
código que muestra dónde y cómo obtenemos los datos que estamos utilizando. Para empezar,
configuraremos la carpeta utilizando el comando `{usethis}` función

```{r cs-create-data-raw, eval=FALSE}
use_data_raw("project-gutenberg")
```

```{r ce-create-data-raw, echo=FALSE}
local_project(project_path, quiet = TRUE)
use_data_raw("project-gutenberg", open = FALSE)
```

Esta función crea la carpeta `data-raw/` así como un script R
dentro, como podemos ver con `dir_tree()`.

```{r ce-show-tree-with-data-raw, echo=FALSE}
dir_tree(project_path)
```

Dentro está el archivo:

```{r cs-inside-empty-data-raw-folder, file=fs::path(project_path, "data-raw", "project-gutenberg.R"), eval=FALSE}
```

Queremos descargar con el tiempo algunos libros, pero de momento descargaremos
[Drácula](https://www.gutenberg.org/ebooks/345). En concreto, queremos
la versión del libro que nos permite cargarlo en R, por lo que el ["Texto sin formato
UTF-8"](https://www.gutenberg.org/cache/epub/345/pg345.txt) es
la que queremos. Encontrarás los libros entrando en [Proyecto
Gutenberg](https://www.gutenberg.org/) escribiendo el nombre del libro en el campo
"Búsqueda rápida" en la esquina superior izquierda de la página, haciendo clic en el libro
y entrando en la página del libro que debe contener el enlace a
la versión en texto plano. Los pasos que queremos dar son

1. Busca un libro, abre el enlace "Texto sin formato UTF-8" y copia la URL en
  la parte superior.
2. Utilizando la URL, descarga el archivo del libro en texto plano y guárdalo en la carpeta
  `data-raw/` carpeta. Aunque podríamos leer el texto directamente desde
  la URL, queremos guardar una copia local por si trabajamos sin conexión
  o en el improbable caso de que el sitio web no funcione.
3. Carga el archivo de texto en R y guárdalo en la carpeta `data/` carpeta. A continuación
  explicaremos por qué hacemos este paso en breve.

Abramos nuestro `data-raw/project-gutenberg.R` script y completamos el
ejercicio siguiente para completar los pasos anteriores en R.

### Ejercicio: Descarga el libro Drácula y guárdalo como datos

Para este ejercicio, tendrás que traducir los pasos indicados anteriormente
a una forma que R entienda. Escribiremos este código en el
`data-raw/project-gutenberg.R` script. Para ayudar a descomponerlo, necesitamos
llegar a R:

1. Cargue los paquetes necesarios: `{fs}`, `{readr}`, `{purrr}` y
  `{here}`. Hasta ahora sólo hemos explicado la `{fs}` paquete.
  - `{readr}`: Lo utilizamos para leer el archivo de texto.
  - `{here}`: Lo utilizamos con fines de reproducibilidad para que cuando
    nos refiramos a las rutas de los archivos, siempre sean relativas al proyecto
    del proyecto (donde el `.Rproj` archivo). Lee la
    [sitio web](https://here.r-lib.org/index.html) para más detalles sobre
    ello.
  - `{purrr}`: Lo utilizamos para descargar y leer en la URL de cada libro.
    Ahora mismo sólo tenemos un libro, pero iremos añadiendo más
    más adelante.
2. Crea un `list()` para la URL del libro (`book_urls`), con la lista
  es el título abreviado del libro. Aunque sólo estamos descargando
  el libro de Drácula en primer lugar, queremos escribir el código de modo que sea
  descargar más libros sin modificar demasiado el código.
  demasiado.
3. Crea una función (`download_then_read()`) que tenga argumentos `url`
  y `book_name` que
  - crea una ruta de archivo desde `book_name` hasta donde debe estar el libro
    descargado utilizando `here()` apuntando a `"data-raw"` y
    `paste0(book_name, ".txt")` (para añadir el final del archivo de texto)
  - comprueba si el archivo existe (`file_exists()`) y lo descarga
    (`download.file()`) si no lo hace
  - entonces lee el archivo en R (`read_lines()`) desde `{readr}`
4. Utiliza `imap()` de `{purrr}` para utilizar el `download_then_read()`
  en cada uno de los libros de `book_urls` y obtener los resultados
  en el objeto `books`.
5. Guarda el `books` lista en el `data/` carpeta utilizando `use_data()`.
  Guardar la carpeta `books` objeto como `.rda` archivo en el `data/` carpeta
  indica a R que los datos son accesibles para los usuarios de nuestro `{zipfs}`
  paquete.

```{r ee-for-copying-project-gutenberg-script-only, eval=FALSE, include=FALSE}
# Use for copying script code to add to chunk below.
# For this exercise, only include the `dracula` book
readr::read_lines(here::here("data-raw/project-gutenberg.R")) |>
    clipr::write_clip()
```

```{r es-download-dracula-book, eval=FALSE}
library(____)
library(____)
library(____)
library(____)

# List with the short name for the book (no spaces or dashes/minuses), along
# the URL.
book_urls <- list(
    ___ = "___"
)

# Function to download the file if it doesn't exist, then read the file into R.
___ <- function(___, ___) {
    # Set the path of the book to `data-raw/` and ending as a `.txt` file.
    book_file_path <- ___("___", paste0(___, "___"))
    # Download text if it isn't already here
    if (!___(book_file_path)) {
        ___(url, book_file_path)
    }
    ___(book_file_path)
}

# `imap()` takes the URLs inside the `book_urls` list as the first argument (`url`) to
# `download_then_read()` and uses the `names()` of the list as the second
# argument (`book_name`). The output is a list of the books.
books <- ___(
    book_urls,
    download_then_read
)

# Save the book list as an .rda file in `data/`.
usethis::use_data(books, overwrite = TRUE)
```

```{r sol-project-gutenberg-script, file=here::here("data-raw", "project-gutenberg.R"), eval=FALSE, echo=-9}
```

### Carga de los datos recién incluidos

Después de completar el ejercicio anterior, habrás visto los mensajes
producidos por `use_data()` con este aspecto:

```{r output-use-data-messages, echo=FALSE}
send_to_null <- suppressMessages(source(here::here("data-raw/project-gutenberg.R"), verbose = FALSE))
usethis::use_data(books, overwrite = TRUE)
```

Los datos a los que quieres que acceda el usuario deben estar incluidos en el fichero `data/`
carpeta y deben estar como `.rda` formato de archivo. También debe ser
documentado adecuadamente, lo que trataremos en @sec-paquete-documentación.

Si recuerdas, utilizamos `load_all()` (`Ctrl-Shift-L` en RStudio) durante
desarrollo del paquete para imitar la instalación del paquete y probar que
funciona. Haremos lo mismo aquí para comprobar que el paquete `books`
se puede acceder a los datos si se instalara nuestro paquete. Ejecuta
`load_all()` y escribe en la consola

```{r cs-show-new-books-data, eval=FALSE}
names(books)
str(books)
```

```{r ce-show-new-books-data, echo=FALSE}
names(books[[2]])
str(books[[2]])
```

Añadiendo más datos al paquete, como más texto de libro al `books`
objeto u otro conjunto de datos, se hace añadiendo más código a
el script en `data-raw/` y volviendo a ejecutar el script, o creando
otro script (si hay un conjunto de datos completamente distinto) utilizando
`use_data_raw()`. Completa el siguiente ejercicio para añadir otro libro al
`data/books.rda` archivo.

### Ejercicio: Incluir a Frankenstein en los datos de los libros

Un libro está bien como punto de partida, pero añadamos otro
para hacerlo más interesante. Añadamos el libro "Frankenstein" a las
`books` datos.

1. Sigue los mismos pasos que seguiste para encontrar el libro de Drácula, pero en lugar de eso
  encuentra la URL del libro Frankenstein. Añade la URL al
  `book_urls` lista dentro del `data-raw/project-gutenberg.R` script.
  Ahora debería tener este aspecto (con el añadido `frankenstein` nombre y
  URL).
  
  ```r
  book_urls <- list(
      ___ = "___",
      dracula = "https://www.gutenberg.org/cache/epub/345/pg345.txt"
  )
  ```

2. Fuente o vuelve a ejecutar el script para reconstruir el `data/books.rda` datos
  de datos.

3. Comprueba que se han añadido los datos ejecutando `load_all()` y escribiendo
  `names(books)` en la consola. Ahora deberías ver algo como
  
  ```{r es-list-added-books}
  names(books)
  ```

Ahora tienes dos libros con los que trabajar para los próximos capítulos.

```{r sol-project-gutenberg-script-with-frankenstein, file=here::here("data-raw", "project-gutenberg.R"), eval=FALSE}
```

## Ejercicio final

Completa estas tareas como parte del paquete de tu primer proyecto
de proyecto. Consulta la asignación del proyecto para obtener detalles exactos sobre lo que
debes crear y qué debe hacer el paquete. Para ello
ejercicio, utilizaremos un paquete sobre el tiempo en Kenia *sólo como
ejemplo y referencia*.

1. Decide un nombre sencillo pero descriptivo para tu nuevo paquete. Utiliza
  `{available}` para ver si el nombre está cogido.

2. Utiliza `create_package()` para crear un nuevo paquete. Aunque puedes crear
  este paquete en cualquier lugar de tu ordenador, por ahora te sugerimos
  tu `Desktop/` o quizás algo como `Documents/r-pkgs/`.

3. Abre el `DESCRIPTION` archivo y actualízalo con:
  
  - Tú mismo como autor en el `Authors@R:` campo
  - Una descripción de una frase del paquete en el `Title:` campo
  - Resumen de dos o tres frases del paquete en el
    `Description:` campo.

4. Añade algunos datos al paquete. Utiliza `use_data_raw()` para crear el paquete
  `data-raw/` junto con un script para limpiar los datos en bruto.
  A continuación, coloca los datos en esta carpeta recién creada. Escribe unos sencillos
  procesos de limpieza de datos en el script R de limpieza y sigue los
  pasos de la Sección FIXME para que los datos FIXME estén disponibles como parte de
  del paquete.

Sabrás que has terminado si

- Tu paquete se puede instalar con `install()` (o `Ctrl-Shift-B` a
  construirlo).
- En una nueva sesión de R, después de ejecutar `library(FIXME)` puedes acceder a
  a los datos por su nombre.

TODO: ¿Añadir aquí las acciones realizadas en el paquete kenyaweather?

```{r ee-chapter-3-assignment, eval=FALSE}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
# TODO: Use temp or use Desktop or use a subfolder in this book's folder?
temp_dir <- fs::path_temp("kenyaweather")
usethis::create_package(
    temp_dir, 
    rstudio = TRUE, 
    open = FALSE,
    fields = list(
        # TODO: Decide which name to use
        `Authors@R` = 'person("Jane", "Doe", email = "jane@example.com",
                          role = c("aut", "cre"))',
        Title = "",
        Description = ""
    )
)

usethis::with_project(temp_dir, {
    usethis::use_blank_slate("project")
    # TODO: Change name for this.
    usethis::use_data_raw("weather", open = FALSE)
}, quiet = TRUE)

fs::dir_tree(temp_dir)
fs::dir_delete(temp_dir)
```

<!-- TODO: Agrupar el paquete final utilizado con Git/zip? ¿moverlo a la carpeta temporal? -->

<!-- TODO: Utiliza git_commit/git_signature para establecer el autor en Sami u otro -->



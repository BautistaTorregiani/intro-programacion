[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción a la Programación II",
    "section": "",
    "text": "Prefacio\nLos conocimientos en programación son esenciales para la práctica de la ciencia de datos, que implica el manejo de grandes conjuntos de datos, junto con la creciente demanda de que los estudios sean reproducibles y abiertos. Con estas exigencias, quienes hacen ciencia de datos necesitan a menudo crear, utilizar y compartir software. Este software tiene características particulares, que están relacionadas en gran medida con la exploración de problemas y la respuesta a preguntas.\nEste libro se desarrollo para la materia Introduccion a la Programacion II y cubre los fundamentos de la creación de software como parte desarrollo y ejecución de proyectos de ciencia de datos abiertos y reproducibles, tanto si la persona trabaja sola como si forma parte de un equipo.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#introducción-para-estudiantes",
    "href": "index.html#introducción-para-estudiantes",
    "title": "Introducción a la Programación II",
    "section": "Introducción para estudiantes",
    "text": "Introducción para estudiantes\nEl objetivo principal de este libro es enseñarte las herramientas, habilidades y conocimientos necesarios para crear software abierto para hacer ciencia de datos de una forma reproducible y sostenible. Esta pensado para personas que investigan o practican ciencias de datos y que ya saben escribir funciones y programas de unos cientos de líneas de codigo y que quieren ser más productivos, tener más confianza en sus resultados y trabajar de forma abierta y reproducible.\nEste libro ofrece una introducción pragmática y basada en herramientas a la ingeniería de software de investigación. Para las personas cuyas tareas incluyen la creación de paquetes de software, este libro le ayudará a ser un ingeniero de software de investigacion. A diferencia de las personas que desarrollan software en la industria o los estudiantes de ciencias de la computacion, este libro utiliza el análisis de datos como ejemplo motivador y asume que el objetivo final de nuestros estudiantes es responder a preguntas y realizar analisis de datos.\nLa ciencia de datos es un proceso que depende de resultados que sean exactos, precisos, replicables y reproducibles. El desarrollo de paquetes de software con fines de investigación nos ayuda a garantizar que los análisis que producen nuestros resultados sean exactamente eso: exactos, precisos, replicables y reproducibles.\nTeniendo esto en cuenta, el principal objetivo de aprendizaje de este libro es que aprendas a gestionar proyectos de ciencia de datos y a desarrollar un paquete R. Al final del libro tendras las habilidades y conocimientos necesarios para: trabajar en proyectos de ciencias de datos ordenados, desarrollar paquetes de R bien construidos, bien documentados y reutilizables y trabajar eficazmente en equipo.\nEstos son los objetivos de aprendizaje específicos que dominarás con este libro:\n\nEscribir programas de R que resuelvan tareas de un proyecto de ciencia de datos.\nProgramar funciones en R.\nExplicar qué es un paquete R, cómo está estructurado y cómo crear uno.\nEnumerar y describir mejores prácticas en el desarrollo de paquetes y cómo implementarlas.\nExplicar qué es una guía de estilo de código, por qué es importante y cómo escribir código que se adhiera a la guía de estilo.\nDescribir por qué la documentación fácil de usar y bien escrita es crucial para construir un paquete utilizable y algunos pasos para lograr este tipo de documentación.\nAplicar técnicas de testeo de software a funciones y paquetes de R.\nDescribir diferentes posibilidades para publicar y compartir un paquete.\nUsar Git y GitHub para monitorear y compartir tu software.\nEncontrar y resolver errores en los programas de R desarrollados.\nEntender como funcionan, que rol y limitaciones tienen los asistentes de programación de IA.\nResolver casos reales de ciencia de datos aplicando las habilidades aprendidas durante la materia.\nOrganizar proyectos de ciencia de datos pequeños a medianos.\nIncorporar el valor del trabajo abierto y reproducible.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#visión-general-de-los-paquetes-creados",
    "href": "index.html#visión-general-de-los-paquetes-creados",
    "title": "Introducción a la Programación II",
    "section": "Visión general de los paquetes creados",
    "text": "Visión general de los paquetes creados\nA lo largo del libro, construirás un paquete de R para leer y analizar datos meteorológicos.\nUtilizaremos datos que diponibiliza el Institulo Nacional de Tecnología Agropecuaria INTA a traves del Sistema de Información y Gestión Agropecuaria SIGA.\nLuego de presentar un tema vamos a realizar ejercicios que nos hagan avanzar en nuestro objetivo de desarrollar este paquete de R en particular.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#sec-licensing",
    "href": "index.html#sec-licensing",
    "title": "Introducción a la Programación II",
    "section": "Reutilización y licencia",
    "text": "Reutilización y licencia\nTodo el material puede reutilizarse libremente bajo los términos de la licencia Creative Commons Reconocimiento 4.0 Internacional Licencia, esto significa que el material puede utilizarse, reutilizarse y modificarse, siempre que se cite esta fuente.\nEl código fuente del libro se encuentra en el repositorio de GitHub intro-programacion. Cualquier corrección, o contribuciones son bienvenidas. Visitá nuestra página sobre como contribuir]() para conocer más.\n\nPrerequisitos\nPara seguir este libro, necesitarás tener instalado git, R y RStudio. Si no los tienes instalados, puedes seguir las instrucciones en la página de instalación.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#convenciones-en-el-libro",
    "href": "index.html#convenciones-en-el-libro",
    "title": "Introducción a la Programación II",
    "section": "Convenciones en el libro",
    "text": "Convenciones en el libro\nEl libro esta ordenado en capitulos que abarcan un tema en particular. Dentro del capitulo podemos presentar ejercicios, ejemplos, consejos, advertencias, etc. Para diferenciar estos elementos utilizamos los siguientes bloques:\n\nEste es un ejercicio\n\n\nEste es un ejemplo\n\n\nA tener en cuenta!\n\n\nEste es un consejo",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#bibliografia",
    "href": "index.html#bibliografia",
    "title": "Introducción a la Programación II",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nGeneral Obligatoria\n\nR Packages (2e) de Hadley Wickham y Jennifer Bryan. Disponible de manera gratuita: https://r-pkgs.org/\nR for Data Science (2e) de Hadley Wickham, Mine Cetinkaya-Rundel y Garrett Grolemund. Disponible de manera gratuita: https://r4ds.hadley.nz/. Primera edición en español: https://es.r4ds.hadley.nz/\n\n\n\nComplementaria\n\nAdvance R de Hadley Wickham. Disponible de manera gratuita: https://adv-r.hadley.nz/\nResearch Software Engineering with Python: Building software that makes research possible de Damien Irving, Kate Hertweck, Luke Johnston, Joel Ostblom, Charlotte Wickham, y Greg Wilson. Disponible de manera gratuita: https://third-bit.com/py-rse/\nrOpenSci editorial team (2024). Paquetes rOpenSci: Desarrollo, mantenimiento y revisión por pares [rOpenSci Packages: Development, Maintenance, and Peer Review] (Traducción al español: Yanina Bellini Saibene, Elio Campitelli, Paola Corrales) Zenodo. https://zenodo.org/doi/10.5281/zenodo.10797248 (Trabajo original publicado en 2024). Disponible de manera gratuita: https://devguide.ropensci.org/es/index.es.html",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#fuentes",
    "href": "index.html#fuentes",
    "title": "Introducción a la Programación II",
    "section": "Fuentes",
    "text": "Fuentes\nEste libro utilizo como fuentes los siguientes materiales:\n\nResearch Software Engineering with Python: Building software that makes research possible de Damien Irving, Kate Hertweck, Luke Johnston, Joel Ostblom, Charlotte Wickham, y Greg Wilson. Disponible de manera gratuita: https://third-bit.com/py-rse/\nR for Data Science (2e) de Hadley Wickham, Mine Cetinkaya-Rundel y Garrett Grolemund. Disponible de manera gratuita: https://r4ds.hadley.nz/. Primera edición en español: https://es.r4ds.hadley.nz/",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00_intro.html",
    "href": "00_intro.html",
    "title": "\n1  Presentación\n",
    "section": "",
    "text": "1.1 Te presentamos R y RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Presentación</span>"
    ]
  },
  {
    "objectID": "00_intro.html#te-presentamos-r-y-rstudio",
    "href": "00_intro.html#te-presentamos-r-y-rstudio",
    "title": "\n1  Presentación\n",
    "section": "",
    "text": "1.1.1 Orientándose en RStudio\nEn principio se podría escribir código de R con el Bloc de Notas y luego ejecutarlo, pero nosotros vamos a usar RStudio, que brinda una interfaz gráfica con un montón de herramientas extra para hacernos la vida más fácil.\nCuando abras RStudio te vas a encontrar con una ventana con cuatro paneles como esta:\n\n\nVentana de RStudio\n\nLos dos paneles de la izquierda son las dos formas principales de interactuar con R. El panel de abajo a la izquierda es la consola. Es el lugar que te permite conversar con R. Podés escribir comandos que se van a ejecutar inmediátamente cuando aprietes Enter y cuyo resultado se va a mostrar en la consola.\nPor ejemplo, hacé click en la consola, escribí 2 + 2 y apretá Enter. Vas a ver algo como esto:\n\n2 + 2\n\n[1] 4\n\n\nLe dijiste a R que sume 2 y 2 y R te devolvió el resultado: 4 (no te preocupes del [1] por ahora). Eso está bueno si querés hacer una cuenta rápida o chequear algo pequeño, pero no sirve para hacer un análisis complejo y reproducible.\nEn el panel de arriba a la izquierda tenemos esencialmente un editor de texto. Ahí es donde vas a escribir si querés guardar instrucciones para ejecutarlas en otro momento y donde vas a estar el 87% de tu tiempo usando R.\nA la derecha hay paneles más bien informativos y que tienen varias solapas que vamos a ir descubriendo a su tiempo. Para destacar, arriba a la derecha está el “environment”, que es forma de ver qué es lo que está “pensando” R en este momento. Ahí vas a poder ver un listado de los datos que están abiertos y otros objetos que están cargados en la memoria de R. Ahora está vacío porque todavía no cargaste ni creaste ningún dato. Abajo a la derecha tienen un explorador de archivos y también el panel de ayuda, que es donde vas a pasar el otro 13% del tiempo usando R.\nEntonces, para resumir:\n\n\nLa cocina de RStudio\n\n\n1.1.2 Hablando con R\nYa viste cómo usar R como una calculadora.\n\n2 + 2\n\n[1] 4\n\n\nR entiende un montón de operaciones aritméticas escritas como seguramente ya te imaginás:\n\n\n+: sumar\n\n-: restar\n\n*: multiplicar\n\n/: dividir\n\n^ o **: exponenciar\n\nPero además conoce muchas otras operaciones. Para decirle a R que calcule el seno de 1 hay que escribir esto:\n\nsin(1)\n\n[1] 0.841471\n\n\nLa sintaxis básica para aplicar cualquier función es nombre_funcion(argumentos).\n\nEn la consola escribí el código de R para calcular las siguientes operaciones:\n\n2 multiplicado por 2\n3 al cuadrado\ndos tercios\n5 por 8 más 1\n\n\nAl hacer todas estas operaciones, lo único que hiciste fue decirle a R que haga esos cálculos. R te devuelve el resultado, pero no lo guarda en ningún lado. Para decirle que guarde el resultado de una operación hay que decirle con qué “nombre” querés guardarlo. El siguiente código hace eso:\n\nx &lt;- 2 + 2\n\nLa “flechita” &lt;- es el operador de asignación, que le dice a R que tome el resultado de la derecha y lo guarde en una variable con el nombre que está a la izquierda. Vas a ver que no te devele el resultado. Para verlo, ejecutamos\n\nx\n\n[1] 4\n\n\nEsto le dice a R que te “imprima” el contenido de la variable x.\n\n¿Qué te imaginás que va a pasar cuando ahora corra el siguiente código?\n\nx + 2\n\n\nPonerle nombre a las variables es a veces la parte más difícil de escribir código. A R le viene bien cualquier nombre de variable siempre y cuando no empiece con un número o un “_”. Pero a los seres humanos que lean el código y tengan que interpretarlos les va a resultas más fácil entender qué hace la variable promedio_temperatura que la variable xxy1.\nEl consejo es tratar en lo posible usar nombre descriptivos y consistentes. Por ejemplo, siempre usar minúsculas y separar palabras con “_”.\n\nPara hacerse la vida más fácil existen “guías de estilo” para programar que explicitan reglas específicas para escribir código. Por ejemplo esta o esta otra. Se trata de reglas únicamente para los ojos humanos, y que no afectan en absoluto la eficiencia o correctitud de la programación. En general, no existen guías buenas o malas, la idea es elegir una y ser consistente. De esta manera, vas a poder entender tu código con más facilidad.\n\n\n1.1.3 Extendiendo R\nR es un lenguaje creado por personas que practican la estadística y pensado para la estadística, por lo que ya viene con un montón de métodos estadísticos incorporados, como mean() o median(). Pero hay tantos métodos estadísticos como gente haciendo estadística así que es imposible que estén todos. La solución es que podés “agregarle” a R funciones que no vienen instaladas por defecto pero que escribieron otras personas en forma de “paquetes”. ¡Este es el poder de la comunidad de R!\nPara instalar paquetes de R, la forma mas fácil es con la función install.packages(). Esta función se conecta a internet y descarga paquetes publicados en un repositorio oficial Entonces, por ejemplo,\n\ninstall.packages(\"readr\")\n\ndescarga e instala un paquete que contiene funciones para leer datos.\n\nPara instalar paquetes de esta forma es necesario tener conexión de internet.\n\nLuego, usando el comando\n\nlibrary(readr)\n\nle decís a R que cargue las funciones que vienen en el paquete readr para usarlas.\n\n\nInstalá el paquete readr con el comando install.packages(\"readr\") en la consola.\nCargá la librería para usarla con library(readr).\n\n\n\nSi cerrás y volveś a abrir R, vas a tener que usar library(readr) nuevamente para acceder a la funcionalidad del paquete readr. Sólo hace falta correr install.packages(\"readr\") una vez por computadora.\n\n\n1.1.4 Buscando ayuda\nEntre la enorme cantidad de funciones que tiene R por defecto y las que se pueden agregar instalando paquetes externos, es imposible recordar todas las funciones y cómo usarlas. Por eso, una gran proporción del tiempo que uses R vas a pasarlo leyendo documentación de funciones, ya sea para aprender a usarlas o porque no te acordás algún detalle.\nPara acceder a la ayuda de una función usamos el signo de pregunta:\n\n?sin\n\nstarting httpd help server ... done\n\n\n\nOtra forma de acceder a la ayuda de una función es poniendo el cursor sobre ella y apretando F1\n\nEsto va a abrir el documento de ayuda para la función sin() que, como verás, tiene la documentación de las funciones trigonométricas que trae R por defecto. Todas las ayudas de R vienen divididas en secciones:\n\nDescription\n\nUna descripción breve de la función o funciones que se documentan.\n\nUsage\n\nNombre de los argumentos de la función. La mayoría de las funciones trigonométricas tienen un solo argumento, que se llama x. La función atan2() tiene dos argumentos, llamados x e y.\n\nArguments\n\nUna descripción de cada argumento. En este caso x e y son vectores numéricos o complejos. Aunque todavía no sepas qué es un “vector”, de esta descripción ya podés intuir que las funciones trigonométricas aceptan números complejos.\n\nDetails\n\nUna descripción detallada de las funciones. Por ejemplo, detalla qué es lo que devuelve la función atan2(), describe las unidades en las que tienen que estar x e y, etc..\n\nValue\n\nDescribe qué tipo de valor devuelve la función.\n\nExamples\n\n(abajo de todo) Es la sección más importante y probablemente la que vas a buscar primero cuando te encuentres con una función nueva que no sabés cómo usar. Acá vas a encontrar código de R de que ejemplifica el uso típico de la función. Podes copiar y pegar el código en la consola y ver el resultado para entender como funciona.\n\n(Otras secciones)\n\nPueden haber otras secciones que detallen distintas particularidades de la función, o referencias a los métodos implementados.\n\n\n\nAbrí y leé la ayuda de la función sd(). Puede que haya cosas que aún no entiendas, pero intentá captar la idea general. Si encesitas traducir la documentación, te recomendamos deepl.\n\n¿Qué hace esa función?\n¿Qué argumentos acepta?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Presentación</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html",
    "href": "01_proyectos.html",
    "title": "\n2  Entorno de trabajo\n",
    "section": "",
    "text": "2.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#objetivos-de-aprendizaje",
    "href": "01_proyectos.html#objetivos-de-aprendizaje",
    "title": "\n2  Entorno de trabajo\n",
    "section": "",
    "text": "Interactuar con la interfaz de RStudio para navegar archivos y directorios\nInterpretar las rutas como ubicaciones dentro de las carpetas\nCrear proyectos RStudio e identificar el directorio de trabajo\nReconocer los paneles de la interfaz de RStudio y sus ubicaciones por defecto",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#el-problema",
    "href": "01_proyectos.html#el-problema",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.2 El problema",
    "text": "2.2 El problema\nImagina que arrancas el cuatrimestre y tenes que continuar con un proyecto de análisis de datos. O mejor te tomaste unas largas vacaciones. Por supuesto, todo el código y los datos están en una única carpeta y además lo publicaste en un repositorio público. Es hora de volver a trabajar, pero ¿qué fue lo último que hiciste? ¿qué falta?.\nEmpezas a revisar la carpeta del proyecto y encuentras algo así.\n/home/dorothy/Documentos/proyecto\n├── resumen.R\n├── correlation.png\n├── datos.csv\n├── datos2.csv\n├── fig1.png\n├── figura2(copy).png\n├── figura.png\n├── figura1.png\n├── figura10.png\n├── datos_crudos.csv\n├── script.R\n└── script_final.R\nY no tienes ni idea por donde arrancar. Hay tres archivos .R que podrían ser el script con el código que escribiste, varios posibles archivos que contienen algunos “datos” no especificados y un montón de archivos de imagenes con nombres que dan poca información sobre su contenido. Sin un archivo README (documento descriptivo) ni ninguna otra documentación que te ayude a resolver este lío, es muy posible que cueste mucho tiempo volver al punto en el que estabas y continuar con tu trabajo.\nPara evitar esta situación necesitamos tener en cuenta la reproducibilidad y el desarrollo de software desde el inicio. La reproducibilidad tiene que ver tanto con las personas que interactúan con el código como con las máquinas que deben ejecutarlo. Hacer que tu código y análisis sea reproducible es permitir que otras personas (y vos en el futuro) puedan revisar, usar y ampliar tu trabajo. Esto requerira aplicar distintos principios de programación y desarrollo de software que veremos a lo largo del curso. Empecemos organizando el trabajo.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#crear-un-proyecto-organizado",
    "href": "01_proyectos.html#crear-un-proyecto-organizado",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.3 Crear un proyecto organizado",
    "text": "2.3 Crear un proyecto organizado\nLo que cuenta como “organizado” es muy personal, pero lo principal es que la estructura de carpetas y los nombres de los archivos deben:\n\nser autodocumentados\nser útiles a la hora de escribir código\nestar en el mismo lugar, es decir, todos los archivos necesarios están dentro de la carpeta raíz\n\n\n2.3.1 Archivos que se autodocumentan\nAprovechá carpetas con nombres informativos para autodocumentar las distintas partes de tu análisis.\nColoca tus datos en datos, los scripts de preprocesamiento en scripts o preprocesamiento y tu análisis en analisis. Utiliza también subcarpetas, como datos/crudos para guardar los datos originales y datos/derivados para los datos preprocesados y depurados.\nNombrá tus archivos de modo que puedas saber que incluyen aún si pasaron 10 años desde que los creaste.\nUtiliza nombres cortos, descripciones breves de lo que hay dentro.\n\nDescribi cuál crees que es el contenido de estos archivos:\n\ndatos/crudos/madrid_temperatura-minima.csv\nscripts/02_calcula_temperatura-media.R\nanalysis/01_madrid_temperatura-minima_analisis-estadistico.Rmd\n\n\n\nPensá en buenos nombres de archivos y carpetas para:\n\nun conjunto de datos sobre gatos con columnas para el peso, la longitud, la longitud de la cola, el color o colores del pelaje, el tipo de pelaje y el nombre.\nun script que descarga datos de Spotify.\nun script que limpia los datos de Spotify.\nun script que ajusta un modelo lineal y lo guarda en un archivo.\nel archivo .Rds en el que se guarda ese modelo.\n\n\n\nUtiliza una estructura de carpetas conocida\nNo existe una única estructura de carpetas objetivamente mejor. En caso de duda, intenta seguir las convenciones de tu comunidad de investigación. Esto minimizará cualquier fricción entre tú y tu público potencial.\n\n\n2.3.2 Archivos con los que puedes programar\nRecuerda siempre que las computadoras son bastante tontas, así que sé amable y utiliza nombres de archivo que puedan entender fácilmente.\nEn algunos casos, los nombres de archivo con espacios confunden a las computadoras, por lo que en general es mucho más fácil trabajar si los nombres de archivo utilizan guiones para dividir las palabras. Del mismo modo, algunas máquinas no pueden manejar “caracteres especiales” como la “ñ” o las tildes. También es mejor evitar algunos símbolos (“.”, “*”, y otros) porque tienen un significado especial en las expresiones regulares.\nAlgunos sistemas de archivos no distinguen entre mayúsculas y minúsculas, por lo que Temperatura-Madrid.csv y temperatura-madrid.csv pueden ser el mismo archivo.\nPara evitar dolores de cabeza, es mejor y por el lado conservador y solo utilizar caracteres latinos en minúsculas, números y guiones (“_” y “-”).\nUtiliza guiones como separadores. Puedes utilizar “-” para separar palabras que formen parte del mismo concepto y “_” para separar conceptos. Por ejemplo temperatura-minima_buenos-aires.csv, en este caso temperatura-minima es un cocepto y buenos-aires otro. Recomendamos esta convención y no al revés, porque es compatible con el formato de fecha ISO (“AAAA-MM-DD”).\n\nSi utilizás los separadores de forma coherente e inteligente, podrás analizar los nombres de los archivos como parte de tu código. Por ejemplo, si tienes\n\narchivos\n\n[1] \"madrid_temperatura-minima\"       \"buenos-aires_temperatura-minima\"\n[3] \"madrid_temperatura-maxima\"       \"buenos-aires_temperatura-maxima\"\n\n\nTambién podrías extraer ciudades y nombres de variables desde los nombres de los archivos\n\nstrsplit(archivos, \"_\")\n\n[[1]]\n[1] \"madrid\"             \"temperatura-minima\"\n\n[[2]]\n[1] \"buenos-aires\"       \"temperatura-minima\"\n\n[[3]]\n[1] \"madrid\"             \"temperatura-maxima\"\n\n[[4]]\n[1] \"buenos-aires\"       \"temperatura-maxima\"\n\n\n\nPor último, intentá que tus archivos sean fácilmente ordenables. Comezá el nombre del archivo con números (que incluya suficientes ceros a la izquierda) y, si aplica, utilizá fechas en formato AAAA-MM-DD para que el orden de los archivos por nombre coincida con el orden por fecha.\n\n2.3.3 Que tu proyecto sea autocontenido\nUn aspecto importante a la hora de pensar en tu proyecto es que todos los scripts, datos, figuras y cualquier otra cosa que se necesite para (re)crear el análisis esté dentro de la misma carpeta raíz. De ese modo te aseguras de que lo único que tienes que dar a otra persona para que ejecute correctamente tu código es esa única carpeta. También te facilita la vida si trabajas en el mismo proyecto en distintas computadoras, ya que te permite sincronizar una única carpeta.\n\nMás adelante veremos como empaquetar código para compartirlo con otras personas.\n\nUn paso extra a tener en cuenta es que no puedes hacer que tu trabajo sea portable si tu código no lo es también. Quizás el principal culpable de que el código no sea portable sea utilizar rutas absolutas para manipular archivos en tu código.\nLa siguiente línea de código lee el archivo datos.csv:\n\nread.csv(\"/home/dorothy/Documentos/proyectos/mitrabajo/datos/datos.csv\")\n\nAunque hayas descargado correctamente la carpeta mitrabajo desde algún repositorio, este código va a dar error porque es poco probable que hayas guardado esa carpeta dentro de Documentos/proyectos y que tu nombre de usuario en la computadora sea “dorothy”.\nEn cambio, podes utilizar una ruta relativa:\n\nread.csv(\"datos/datos.csv\")\n\nEsto se ejecutará independientemente de dónde se encuentre la carpeta raíz de tu proyecto ya que hace referencia solo a lo que está adentro. Como veremos a continuación los proyectos de RStudio ayudan a definir cual es la carpeta raíz de manera automática.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#proyectos-de-rstudio",
    "href": "01_proyectos.html#proyectos-de-rstudio",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.4 Proyectos de RStudio",
    "text": "2.4 Proyectos de RStudio\nRStudio proporciona una forma ordenada y estructurada de separar tus proyectos en diferentes contextos. No ayudan estrictamente a la reproducibilidad del producto final, pero te ayudarán a agilizar tu flujo de trabajo encapsulando cosas como la lista de archivos abiertos, el historial de comandos de R y la configuración de RStudio para cada proyecto.\nAbrir un proyecto de RStudio también garantiza que inicies una nueva sesión de R cada vez y establece tu directorio de trabajo en la carpeta raíz del proyecto.\n\nCreá un nuevo proyecto de RStudio\n\nHace clic en “File” y luego en “New Project…”.\nHace clic en “New directory”.\nVerás una lista de varias plantillas. Selecciona “New project”.\nEscribí el nombre de la carpeta raíz en la que vivirá tu proyecto y selecciona la ubicaciónn en la que quieres que se cree esta carpeta haciendo clic en “Browse”.\nHace clic en “Create project”.\n\n\n¿Cuál es la ruta absoluta a la carpeta de tu proyecto?\nSi cerrás RStudio, ¿cómo podés asegurarte de que tu carpeta de trabajo es la carpeta de tu proyecto la próxima vez que abras RStudio?\n\n\nSi todo salió bien, deberías tener una nueva carpeta con el nombre que elejiste para tu proyecto. Es una carpeta común y corriente; lo que la distingue como proyecto de RStudio es el archivo .Rproj, que contiene las opciones de RStudio específicas del proyecto, y la carpeta oculta .Rproj.user, donde se encuentran los archivos temporales específicos del proyecto.\nCada proyecto de RStudio tiene su propio conjunto de opciones que podés cambiar sin alterar las opciones globales ni las de otros proyectos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#abrir-un-proyecto",
    "href": "01_proyectos.html#abrir-un-proyecto",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.5 Abrir un proyecto",
    "text": "2.5 Abrir un proyecto\nLa forma más sencilla de abrir un proyecto es abrir la carpeta que lo contiene y hacer doble clic en el archivo .Rproj. También puedes abrir rápidamente un proyecto utilizado recientemente haciendo clic en el icono de proyecto situado a la derecha de la barra de herramientas de RStudio.\nEsto abrirá una nueva ventana de RStudio con su propia sesión de R y la carpeta del proyecto será el directorio o carpeta raiz. Por defecto, también abrirá los archivos abiertos anteriormente. Incluso conservará los cambios no guardados. Esto ayuda a mantener tu trabajo ordenado y facilita retomar o compartir lo que has hecho más tarde.\nRStudio te permite tener abiertos varios proyectos, y esto es posible porque cada proyecto tiene su propia carpeta. Puedes trabajar con varios proyectos en paralelo sin que el código o los resultados de un análisis interfieran con los de otro.\n\nAbrí tu proyecto\n\nEn tu nuevo proyecto, crea un nuevo archivo .R y escribe algo de código (por ejemplo print(\"Hola!\") o x &lt;- 2 + 2), no te olvides de guardarlo.\nCerrá la ventana de RStudio.\nAhora abrí una nueva ventana de RStudio y el proyecto de RStudio que acabas de cerrar (dependiendo de tus opciones globales, puede que se abra por defecto).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#borrón-y-cuenta-nueva-todos-los-días",
    "href": "01_proyectos.html#borrón-y-cuenta-nueva-todos-los-días",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.6 Borrón y cuenta nueva… todos los días",
    "text": "2.6 Borrón y cuenta nueva… todos los días\n¿Cómo garantizamos que el análisis sea realmente reproducible? Es una pregunta bastante amplia y existen muchas herramientas para resolver este problema. Por ahora vamos a concentrarnos en que, al menos en tu computadora, puedas repetir los cálculos o el análisis desde cero. Y además de organizar los proyectos y no modificar los datos originales, ¿cómo podés asegurarte de guardar todo el código que estuviste usando y genera el análisis? La forma más directa es reiniciar la sesión de R y volver a ejecutar el código, si da un error o no devuelve lo que esperabas significa que te has saltado un paso.\n\nPuedes reiniciar la sesión de R con el atajo de teclado Ctrl+Shif+F10.\n\nEsto puede ocurrir si, por ejemplo, lees datos en memoria ejecutando un comando en la consola. Mientras trabajamos, R tendrá esos datos en memoria y podrás hacer cálculos y gráficos, pero tu código no será reproducible porque le falta el paso importante de leer los datos.\nLa mejor forma de asegurarte de que esto no ocurra es volver a ejecutar tu código en una sesión nueva de R a menudo, para asegurarte de que tu código es reproducible en cada paso del análisis. Sin embargo, por defecto RStudio guardará el entorno en un archivo oculto llamado .RData y lo restaurará al iniciarse, de modo que los datos seguirán estando en la memoria. Y aunque esto resulta útil para que puedas arrancar tu trabajo exactamente donde lo dejaste cada vez que abras tu proyecto, puede llevar a una situación en la que nunca te des cuenta de que se te pasó guardar una línea de código clave en tu análisis.\n\nConfigurá tu proyecto\n\nVe a “Tools” -&gt; “Project options…”.\nEn la pestaña “General”\n\n\nDestildar la opción “Restore .RData into the workspace at startup”\n“Save workspace to .RData on exit”: Selecciona “Never” en el menú desplegable\n\n\n\nPuedes cambiar estas preferencias a nivel global con “Tools” -&gt; “Global Options” en la sección “General”\n\n\n2.6.1 Recursos\nEstructura del proyecto - Diapositivas de Danielle Navarro\nEmpaquetar el trabajo analítico de datos de forma reproducible utilizando R (y amigos)\nCómo (y por qué) hacer un compendio de investigación",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "02_lectura.html",
    "href": "02_lectura.html",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "",
    "text": "3.1 Trabajando con datos\nMuchas veces los datos están disponibles en distintos servicios en páginas de internet. Muchos gobiernos por ejemplo, tienen portales de datos abiertos. Organizaciones generan APIs (Interfaz de programación de aplicaciones, Application programming interface en Ingles) para poner a disposición sus datos o tal vez otras personas publicaron sus datos en servicios como Zenodo y queremos aprovecharlos. Es posible que se puedan decargar los datos visitando la web y haciendo click en un botón, sin embargo podríamos escribir el código necesario para hacer esto de manera programática. Esto hace que nuestro trabajo sea más reproducible y disminuye las chances de error.\nEl código que genera la descarga de datos podría estar incluido en el archivo de análisis de datos si la descarga no demora. En general querremos incluir la opción de no descargar los datos si el código encuentra que ya fueron descargados previamente. También podríamos generar un script de descarga de datos que corra una sola vez. Esta es una buena idea cuando el código de descarga demora o es complejo.\nVeamos un ejemplo de descarga de datos desde Zenodo.\nSi revisamos la base de datos https://zenodo.org/records/12772944 veremos que incluye un solo archivo en formato .csv.\nVemos también el botón “Download” para la descarga del archivo. Podríamos usarlo para descargar el archivo haciendo click.\nPero como mencionaba previamente, se puede escribir el código necesario para hacer la descarga de manera programática y asegurarnos que tenemos los datos correctos y actualizados.\nPara eso, primero necesitás la dirección (URL) del set de datos. Eso se consigue yendo a la página del set de datos y en vez de hacer click en Download, haciendo\nLa URL de esta base de datos es https://zenodo.org/records/12772944/files/pinguinos.csv?download=1. Guardamos eso en una variable en R\npinguinos_url &lt;- \"https://zenodo.org/records/12772944/files/pinguinos.csv?download=1\"\nY también definimos la ruta donde descargar el archivo\npinguinos_archivo &lt;- \"datos/pinguinos.csv\" # esta ubicación, o sea la carpeta datos debe existir!\nY finalmente usamos la función download.file() para descargar el archivo.\ndownload.file(url = pinguinos_url, destfile = pinguinos_archivo)\nY esto va a descargar la última versión de los datos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "02_lectura.html#trabajando-con-datos",
    "href": "02_lectura.html#trabajando-con-datos",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "",
    "text": "Click derecho → Copiar dirección del enlace",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "02_lectura.html#leer-datos-csv",
    "href": "02_lectura.html#leer-datos-csv",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "\n3.2 Leer datos csv",
    "text": "3.2 Leer datos csv\nExisten muchas funciones distintas para leer datos dependiendo del formato en el que están guardados. Para datos tabulares (filas y columnas), la forma más útil es el formato csv, que es un archivo de texto plano con datos separados por coma.\nEn R hay muchas maneras de hacer cada cosa, por ejemplo podríamos leer el archivo con la función read.csv(), con read_csv() del paquete readr o fread() del paquete data.table entre otras opciones. Nos vamos a quedar con la opción que nos da readr que tiene algunas características interesantes.\n\nlibrary(readr)\npinguinos &lt;- read_csv(\"datos/pinguinos.csv\")\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): especie, isla, sexo\ndbl (5): largo_pico_mm, alto_pico_mm, largo_aleta_mm, masa_corporal_g, anio\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nNotá que en este caso el código para leer los datos consta de dos líneas. La primera carga el paquete readr y el segundo usa la función read_csv() (del paquete readr) para leer el archivo .csv. No es necesario cargar el paquete cada vez que vas a leer un archivo, pero asegurate de incluir la carga de paquetes al comienzo de tu codigo.\n\nTodo ese texto naranja/rojo es intimidante pero no te preocupes, es sólo un mensaje que nos informa que los datos se leyeron y qué tipo de dato tiene cada columna. Podemos explorar la estructura de la variable pinguinos usando la función str() (de structure en inglés).\n\nstr(pinguinos)\n\nspc_tbl_ [344 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ especie        : chr [1:344] \"Adelia\" \"Adelia\" \"Adelia\" \"Adelia\" ...\n $ isla           : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ largo_pico_mm  : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ alto_pico_mm   : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ largo_aleta_mm : num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ masa_corporal_g: num [1:344] 3750 3800 3250 NA 3450 ...\n $ sexo           : chr [1:344] \"macho\" \"hembra\" \"hembra\" NA ...\n $ anio           : num [1:344] 2007 2007 2007 2007 2007 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   especie = col_character(),\n  ..   isla = col_character(),\n  ..   largo_pico_mm = col_double(),\n  ..   alto_pico_mm = col_double(),\n  ..   largo_aleta_mm = col_double(),\n  ..   masa_corporal_g = col_double(),\n  ..   sexo = col_character(),\n  ..   anio = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nEsto nos dice un montón. La primera línea dice que es una tibble, que es un caso especial de la estructura de datos tabular básica de R llamada data.frame. Tiene 344 filas (las observaciones) y 8 columnas (o variables que describen las observaciones). Las siguientes líneas nos dicen los nombres de las columnas (especie, isla, largo_pico_mm, alto_pico_mm, largo_aleta_mm, masa_corporal_g, sexo, y anio), su tipo de dato (chr o num), la longitud ([1:344]) y sus primeros elementos.\n\nEn el portal de datos de Argentina encontramos muchos conjuntos de datos con informacion oficial. Vamos a descargar y leer un archivo de Excel.\n\nDirigirse a esta pagina web con datos abiertos: https://datos.gob.ar/dataset/produccion-innovacion-productiva-empresas-que-mas-invierten-id-nivel-mundial\nRealizar los pasos necesarios para descargar el archivo de Excel del conjunto de datos “Las 50 empresas más innovadoras entre 2013 y 2019” de forma programatica.\nCargar el conjunto de datos en r y explorar su estructura con la función str().\nContestar:\n\n4.1 ¿Cuántas columnas y filas tiene el data.frame?\n4.2 ¿Qué tipo de dato hay en cada columna? ¿el tipo de dato es correcto según el contenido que vez?\n4.3 ¿Que funcion usaste para leer el archivo de Excel?\nAl final del ejercicio deberías tener un archivo .qmd o .R con el código que lo resuelve. Nombrá el archivo siguiendo los consejos que vimos en clase.\n\n\n3.2.1 Construyendo un paquete de R paso a paso\n\nA lo largo del curso vamos a construir y probar paquete de R que nos permita trabajar y analizar datos de estaciones meteorológicas. El objetivo de este ejercicio es que comiences a familiarizarte con estos datos.\nUtilizaremos datos que diponibiliza el Institulo Nacional de Tecnología Agropecuaria INTA a traves del Sistema de Información y Gestión Agropecuaria SIGA. Por ahora y para practicar lo que vimos en esta sección, usaremos una parte de esos datos que guardamos en un repositorio.\n\nMetadatos: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/metadatos_completos.csv\nEstación NH0472: https://github.com/rse-r/intro-programacion/blob/main/datos/NH0472.csv\nEstación NH0910: https://github.com/rse-r/intro-programacion/blob/main/datos/NH0910.csv\nEstación NH0046: https://github.com/rse-r/intro-programacion/blob/main/datos/NH0046.csv\nEstación NH0098: https://github.com/rse-r/intro-programacion/blob/main/datos/NH0098.csv\nEstación NH0437: https://github.com/rse-r/intro-programacion/blob/main/datos/NH0437.csv\n\n\nEscribe el código necesario para descargar losr archivos y guardalos en la carpeta datos de tu proyecto. Utiliza las url provistas en el listado. Piensa en nombres adecuados para tus archivos segun lo que vimos en el segundo capitulo.\nLee los datos descargados, para eso revisa la ayuda de la funcion read_csv()`.\nExplora la estructura de los data.frames con la función str(). También podés usar glimpse() del paquete dplyr\n\n\n¿Cuántas columnas tiene cada tabla? ¿son todas iguales?\n¿Qué tipo de dato hay en cada columna? ¿el tipo de dato es correcto según el contenido que vez?\n¿Cuántos registros hay que cada data frame?\n\n\n\n3.2.2 Recursos\nUsando Apache Arrow para analizar el padron electoral argentino del 2011",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html",
    "href": "03_manipulacion-1.html",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "",
    "text": "4.1 Seleccionando columnas con select()\nPara quedarse únicamente con las columnas de especie y largo del pico, usá select()\nselect(pinguinos, especie, largo_pico_mm)\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows\n¿Dónde quedó este resultado? Si te fijás en la tabla pinguinos, su formato no cambió, sigue teniendo todas las columnas originales a pesar de nuestro select:\npinguinos\n\n# A tibble: 344 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\nselect() y el resto de las funciones de dplyr siempre generan una nueva tabla y nunca modifican la tabla original. Para guardar la tabla con las dos columnas especie e largo_pico_mm tenés que asignar el resultado a una nueva variable.\npinguinos_isla &lt;- select(pinguinos, especie, largo_pico_mm)\npinguinos_isla\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#seleccionando-columnas-con-select",
    "href": "03_manipulacion-1.html#seleccionando-columnas-con-select",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.1 Seleccionando columnas con select()\n",
    "text": "4.1 Seleccionando columnas con select()\n\nPara quedarse únicamente con las columnas de especie y largo del pico, usá select()\n\nselect(pinguinos, especie, largo_pico_mm)\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows\n\n\n¿Dónde quedó este resultado? Si te fijás en la tabla pinguinos, su formato no cambió, sigue teniendo todas las columnas originales a pesar de nuestro select:\n\npinguinos\n\n# A tibble: 344 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\nselect() y el resto de las funciones de dplyr siempre generan una nueva tabla y nunca modifican la tabla original. Para guardar la tabla con las dos columnas especie e largo_pico_mm tenés que asignar el resultado a una nueva variable.\n\npinguinos_isla &lt;- select(pinguinos, especie, largo_pico_mm)\npinguinos_isla\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows\n\n\n\n\nCómo funciona select()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#filtrando-filas-con-filter",
    "href": "03_manipulacion-1.html#filtrando-filas-con-filter",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.2 Filtrando filas con filter()\n",
    "text": "4.2 Filtrando filas con filter()\n\nAhora podés usar filter() para quedarte con sólo unas filas. Por ejemplo, para quedarse con los pingüinos de la especie Adelia:\n\nfilter(pinguinos, especie == \"Adelia\")\n\n# A tibble: 152 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 142 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\nLa mayoría de los análisis consisten en varios pasos que van generando tablas intermedias (en el primer desafío usaste 4 pasos para calcular la proporción entre el largo de la aleta y del pico) La única tabla que te interesa es la última, por lo que ir asignando variables nuevas en cada paso intermedio es tedioso y poco práctico. Para eso se usa el operador ‘pipe’ (|&gt;).\nEl operador ‘pipe’ (|&gt;) agarra el resultado de una función y se lo pasa a la siguiente. Esto permite escribir el código como una cadena de funciones que van operando sobre el resultado de la anterior.\nLas dos operaciones anteriores (seleccionar tres columnas y luego filtrar las filas correspondientes a Argentina) se pueden escribir uno después del otro y sin asignar los resultados intermedios a nuevas variables de esta forma:\n\npinguinos |&gt; \n  filter(especie == \"Adelia\") |&gt; \n  select(especie, largo_pico_mm)\n\n# A tibble: 152 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 142 more rows\n\n\nLa forma de “leer” esto es “Tomá los datos en el data.frame pinguinos, después aplicale filter() tal que la especie sea Adelia, después aplicale select() para quedarte con la especie y el largo_pico_mm.\n\nEs posible que te encuentres o te hayas encontrado con esta otra versión del operador pipe %&gt;%. Esta es la pipe del paquete magritter, que usamos durante muchísimo tiempo (y seguimos usando) hasta que la nueva pipe |&gt; se sumo a R 4.0.0.\n\nCómo vimos, el primer argumento de todas las funciones de dplyr es el data frame sobre el cual van a operar, pero notá que en las líneas con select() y filter() no escribís la tabla explícitamente.\nEsto es porque la pipe implícitamente pasa el resultado de las líneas anteriores como el primer argumento de la función siguiente.\nToma el data frame pinguinos y se lo pasa al primer argumento de filter(). Luego el data frame resultante de esa operación pasa como el primer argumento de la función select() gracias al |&gt;.\n\nEn RStudio podés escribir |&gt; usando el atajo de teclado Ctr + Shift + M. ¡Probalo!\n\n\nCompletá esta cadena de código para producir una tabla que contenga los pingüinos con aletas mayores a 200 mm y la información de la especie y el largo de la aleta.\n\npinguinos |&gt; \n  filter(largo_aleta_mm &gt; ___) |&gt; \n  select(_____, ____)\n\n\nComo seguramente notaste en el ejercicio cuando aplicamos filtros usamos operaciones lógicas que devuelven TRUE o FALSE según si cumplen o no con la condición. Para esto usamos operadores lógicos como ==, &gt;, &lt;, &gt;=, &lt;=, etc. R tiene varios operadores lógicos:\n\n\nOperador\nDefinición\n\n\n\n&lt;\nmenor que\n\n\nx|y\nx o y\n\n\n&lt;=\nmenor o igual a\n\n\nis.na(x)\nchequea si x es NA\n\n\n!is.na(x)\nchequea si x no es NA\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual a\n\n\nx %in% y\nchequea si x esta en y\n\n\n!(x %in% y)\nchequea si x no esta en y\n\n\n==\nigual a\n\n\n!=\nno igual a\n\n\n!x\nno x\n\n\nx & z\nx y z\n\n\n\n\nEs hora de revisar lo que vimos hasta acá.\n\nDescargá el archivo que se encuentra en este link y guardalo en tu proyecto de trabajo en clase.\nResolvé los ejercicios propuestos de lectura (yapa!) y de filtros. En algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nEl archivo tiene más ejercicios, pero no te adelantes. Vamos a ver esos temas a continuación.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#agrupando-y-reduciendo-con-group_by-summarise",
    "href": "03_manipulacion-1.html#agrupando-y-reduciendo-con-group_by-summarise",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.3 Agrupando y reduciendo con group_by() |> summarise()\n",
    "text": "4.3 Agrupando y reduciendo con group_by() |&gt; summarise()\n\nSi quisieramos responder ¿cuál es el largo promedio de la aleta para cada especie de pingüino? tenemos que usar un combo de funciones: group_by() |&gt; summarise(). Es decir, primero agrupamos las filas de nuestro data.frame según la columna especie (esto genera 3 grupos) y luego calculamos el promedio de largo_aleta_mm para cada grupo.\nVamos paso a paso.\n\npinguinos |&gt; \n  group_by(especie) \n\n# A tibble: 344 × 8\n# Groups:   especie [3]\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\nA primera vista parecería que la función no hizo nada, pero fijate que el resultado ahora dice que tiene grupos (“Groups:”), y nos dice qué columna es la que agrupa los datos (“especie”) y cuántos grupos hay (“3”). Cualquier operación que hagamos a continuación del group_by() van a aplicarse para cada grupo.\nPara ver esto en acción, usá summarise() para computar el promedio del largo de la aleta.\n\npinguinos |&gt; \n  group_by(especie) |&gt;   \n  summarise(aleta_promedio = mean(largo_aleta_mm, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  especie aleta_promedio\n  &lt;chr&gt;            &lt;dbl&gt;\n1 Adelia            190.\n2 Barbijo           196.\n3 Papúa             217.\n\n\n¡Tadá! summarise() devuelve una tabla con una columna para la especie y otra nueva, llamada “aleta_promedio” que contiene el promedio de del largo de la aleta para cada grupo.\ngroup_by() permite agrupar en base a múltiples columnas y summarise() permite generar múltiples columnas de resumen. El siguiente código calcula la cantidad de pingüinos por especie y por isla y el promedio de su masa corporal.\n\npinguinos |&gt; \n  group_by(especie, isla) |&gt; \n  summarise(cantidad = n(),\n            promedio_masa_corporal = mean(masa_corporal_g, na.rm = TRUE))\n\n`summarise()` has grouped output by 'especie'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 4\n# Groups:   especie [3]\n  especie isla      cantidad promedio_masa_corporal\n  &lt;chr&gt;   &lt;chr&gt;        &lt;int&gt;                  &lt;dbl&gt;\n1 Adelia  Biscoe          44                  3710.\n2 Adelia  Dream           56                  3688.\n3 Adelia  Torgersen       52                  3706.\n4 Barbijo Dream           68                  3733.\n5 Papúa   Biscoe         124                  5076.\n\n\n\nLa función n() cuenta la cantidad de elementos en cada grupo, en este caso la cantidad de pingüinos por especie e isla. A diferencia de otras funciones que venimos usando no requiere de ningún argumento para funcionar en el contexto de summarise()\n\nEl resultado va a siempre ser una tabla con la misma cantidad de filas que grupos y una cantidad de columnas igual a la cantidad de columnas usadas para agrupar y los estadísticos computados.\n\n¿Cuál te imaginás que va a ser el resultado del siguiente código? ¿Cuántas filas y columnas va a tener? (Tratá de pensarlo antes de correrlo.)\n\npinguinos |&gt; \n   summarise(promedio_pico = mean(largo_pico_mm, na.rm = TRUE))\n\n\nEl combo group_by() |&gt; summarise() se puede resumir en esta figura. Las filas de una tabla se dividen en grupos, y luego cada grupo se “resume” en una fila en función del estadístico usado.\n\n\n4.3.1 reframe() entra a la cancha\nsummarise() funciona re bien hasta que que nos encontramos con la necesidad de hacer cuentas más complejas. Por ejemplo, supongamos que queremos calcular el cuantil 0.25 de la masa corporal porque decidimos que todos los pinguinos con un peso por debajo de ese valor son “pequeños”. Con lo que vimos hasta ahora podemos calcularlo.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  summarise(cuantil_masa = quantile(masa_corporal_g, c(0.25), na.rm = TRUE))\n\n# A tibble: 3 × 2\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Barbijo        3488.\n3 Papúa          4700 \n\n\nPero se vuelve tedioso si queremos otros cuantiles, por ejemplo el 0.75 (porque decidimos los pingüinos con masa mayor a ese valor sn “grandes”). Si intentamos extender el código anterior además del resultado vamos a terminar con un warning enorme.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  summarise(cuantil_masa = quantile(masa_corporal_g, c(0.25, 0.75), na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n`summarise()` has grouped output by 'especie'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 6 × 2\n# Groups:   especie [3]\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Adelia         4000 \n3 Barbijo        3488.\n4 Barbijo        3950 \n5 Papúa          4700 \n6 Papúa          5500 \n\n\nEl problema es que estamos opteniendo 2 valores para cada grupo, es decir el cuantil 0.25 y el 0.75 para cada especie. En estos casos tenemos que usar reframe() que funciona de manera similar a summarise() pero está pensada para estos casos donde calculamos más de un valor por grupo.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  reframe(cuantil_masa = quantile(masa_corporal_g, c(0.25, 0.75), na.rm = TRUE))\n\n# A tibble: 6 × 2\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Adelia         4000 \n3 Barbijo        3488.\n4 Barbijo        3950 \n5 Papúa          4700 \n6 Papúa          5500",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#creando-nuevas-columnas-con-mutate",
    "href": "03_manipulacion-1.html#creando-nuevas-columnas-con-mutate",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.4 Creando nuevas columnas con mutate()\n",
    "text": "4.4 Creando nuevas columnas con mutate()\n\nTodo esto está bien para hacer cálculos con columnas previamente existentes, pero muchas veces tenés que crear nuevas columnas.\nPodríamos querer expresar la masa corporal de los pingüinos en kilos en vez de gramos.\n\npinguinos |&gt; \n  mutate(masa_corporal_kg = masa_corporal_g/100)\n\n# A tibble: 344 × 9\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 2 more variables: anio &lt;dbl&gt;, masa_corporal_kg &lt;dbl&gt;\n\n\nRecordá que las funciones de dplyr nunca modifican la tabla original. mutate() devolvió una nueva tabla que es igual a la tabla pinguinos pero con la columna “masa_corporal_kg” agregada al final. Si no asignamos este resultado a una variable, no podremos usarlo luego.\nLa función mutate() además de permitir crear nuevas columnas, también permite modificar o actualizar columnas existentes. Para eso, solo es necesario asignarle el nombre de la columa que queremos modificar.\n\npinguinos |&gt; \n  mutate(especie = toupper(especie))\n\n# A tibble: 344 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 ADELIA  Torg…          39.1         18.7            181            3750 macho\n 2 ADELIA  Torg…          39.5         17.4            186            3800 hemb…\n 3 ADELIA  Torg…          40.3         18              195            3250 hemb…\n 4 ADELIA  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 ADELIA  Torg…          36.7         19.3            193            3450 hemb…\n 6 ADELIA  Torg…          39.3         20.6            190            3650 macho\n 7 ADELIA  Torg…          38.9         17.8            181            3625 hemb…\n 8 ADELIA  Torg…          39.2         19.6            195            4675 macho\n 9 ADELIA  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 ADELIA  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\n\n¿Te acordás del ejercicio que arrancaste cuando vimos filtros? Es hora de completarlo!\n\nCompletá los ejercicios de este archivo que ya deberías tener en tu proyecto.\nTe vas a encontrar con ejercicios para practicar summarise() y mutate(). De nuevo, en algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nCuando hayas terminado, knitea el archivo para generar un html y ver como queda el resultado.\n\n\n\n4.4.1 Construyendo un paquete de R paso a paso\n\nAhora que ya tenés las herramientas para manipular y transformar datos ordenados, es hora de familiarizarte más con los datos de las estaciones meteorológicas.\nTe proponemos responder a las siguientes preguntas manipulando los datos con los verbos de dplyr que vimos hasta ahora. Pero seguramente necesites nuevas funciones, te iremos dando pistas en el camino.\nPero antes de eso, sería útil tener todos los datos de las estaciones en un solo data.frame. Seguramente los leiste por separado y cada uno tiene un nombre distinto. La función rbind() permite unir data.frames uno debajo del otro. Usá el siguiente código y completalo para generar un data.frame con los datos de todas las estaciones.\nnuevo_nombre &lt;- rbind(___, ____, ____)\nPreguntas\n\n¿Cuántas observaciones de temperatura se hicieron en cada estación?\n¿Cuál es la temperatura mínima registrada y la máxima registrada en cada estación?\n¿Cuál es el promedio de la temperatura de abrigo a 150 cm en cada estación? ¿Y el desvío estandar? Pista: la mayoría de las funciones tienen un argumento para sacar los NA del cálculo, revisá la documentación de mean() y de sd().\n¿Cuál es la proporción de NA en temperatura de abrigo a 150 cm? Pista: podés calcular la proporción como cantidad de NA dividido la cantidad total de observaciones. La función is.na() devuelve TRUE si el valor es un NA, al mismo tiempo TRUE es igual a 1 (así es como R lo interpreta) por lo que sum(is.na(variable)) te va a dar la cantidad de NA en esa variable.\n¿Cuál es el promedio anual de la temperatura de abrigo a 150 cm en cada estación? Pista, podés extraer el año de la variable fecha con anio = year(fecha) y usar esa nueva variable para agrupar los datos.\n¿Cuál es la precipitación acumulada mensual en cada estación? Pista: la precipitación acumulada mensual es la suma de la precipitación en cada mes. En este caso necesitas agrupar los datos por año y mes, una posibilidad es usar floor_date(fecha, \"month\").",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "04_git-1.html",
    "href": "04_git-1.html",
    "title": "5  git para trabajar individualmente",
    "section": "",
    "text": "5.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#objetivos-de-aprendizaje",
    "href": "04_git-1.html#objetivos-de-aprendizaje",
    "title": "5  git para trabajar individualmente",
    "section": "",
    "text": "Identificar por qué el control de versiones, específicamente Git, es importante para el desarrollo de software y análisis de datos.\nDiferenciar métodos para trabajar con Git y R: integración con RStudio.\nAplicar el proceso de modificación-add-commit como el flujo de trabajo de Git para el seguimiento de los cambios y ver el historial de commits de un repositorio.\nPublicar repositorios en GitHub y coordinar versiones remotas y locales.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#por-qué-git",
    "href": "04_git-1.html#por-qué-git",
    "title": "5  git para trabajar individualmente",
    "section": "5.2 ¿Por qué git?",
    "text": "5.2 ¿Por qué git?\n¿Tenés algo así en tu computadora?\n/home/pao/Documents/Clases/progrmacion\n├── script.R\n├── tp.Rmd\n├── tp_corregido.Rmd\n├── tp_corregido2.Rmd\n├── tp_final.Rmd\n├── tp_finalfinal.Rmd\n├── este_es_el_final.Rmd\n├── juro_que_esta_es_la_ultima_version_del_tp.Rmd\n└── FINAL.Rmd\nProbablemente todos lo tenemos, o tuvimos algo así en algún momento, porque necesitamos guardar nuestro trabajo pero seguir teniendo acceso a versiones anteriores. Existe una solución para esto. Los sistemas de control de versiones gestionan la evolución y los cambios de un conjunto de archivos que llamaremos repositorio. Si alguna vez has mirado el historial de un archivo de Google Docs, es así pero de una forma muy controlada. Git es un sistema de control de versiones muy popular, pero hay otros.\nSi trabajas de manera individual, git es estupendo para hacer un seguimiento de los cambios y recuperar versiones anteriores de tus archivos. También puedes utilizar un repositorio remoto (que veremos más adelante) para tener una copia de seguridad y compartir tu trabajo.\nSi trabajas en equipo, podés aprovechar todo lo anterior y utilizar también el control de versiones como herramienta para colaborar y organizar las distintas versiones de un mismo archivo presentes en las múltiples computadoras que vos y las otras personas usen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#pero-qué-entendemos-por-control-de-versiones",
    "href": "04_git-1.html#pero-qué-entendemos-por-control-de-versiones",
    "title": "5  git para trabajar individualmente",
    "section": "5.3 Pero, ¿qué entendemos por control de versiones?",
    "text": "5.3 Pero, ¿qué entendemos por control de versiones?\nImaginemos que tenemos un repositorio funcionando (más adelante veremos cómo crear uno). Cuando creas un nuevo archivo como parte del repositorio (o repo), ese archivo no es trackeado o no está versionado. Esto significa que git ignorará el archivo y cualquier cambio que hayas hecho hasta que lo agregues al repositorio (add en inglés) y empieces a registrar sus cambios. En ese momento el archivo está en el area staging (en el escenario de git) y está listo para entrar en el repositorio. Para eso hay que confirmar (commit en inglés) esa versión del archivo en el repositorio. Este flujo de trabajo modify --&gt; add --&gt; commit se repetirá cada vez que quieras guardar una versión del archivo.\n\nNo recomendamos hacer un commit cada vez que guardes el archivo o cambies una coma, y tampoco es buena idea hacer un commit con mil millones de cambios. Con la práctica y dependiendo de cómo trabajes, encontrarás un punto medio cómodo.\n\n\n\n\nLa figura muestra el ciclo de cambios en un archivo: versionado o sin versional. Cuando es versionado y forma parte del repositorio, las acciones son add, commit, y modificar. Con la acción add, el archivo se “prepara”; con la acción de commit, el archivo se “guarda” en el repositorio. Este ciclo se repite cada vez que se modifica el archivo.\n\n\nMencionamos las acciones add y commit que son los nombres de dos comandos de git. Si tenes experiencia trabajando con la terminal podés utilizar git desde ahí, pero los mismos comandos pueden ejecutarse desde una GUI como GitHub Desktop o GitKraken. Durante este curso utilizaremos RStudio.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#ya-mencionamos-repositorio-remoto",
    "href": "04_git-1.html#ya-mencionamos-repositorio-remoto",
    "title": "5  git para trabajar individualmente",
    "section": "5.4 ¿Ya mencionamos “repositorio remoto”?",
    "text": "5.4 ¿Ya mencionamos “repositorio remoto”?\nAntes revisamos el flujo de trabajo local. El repositorio (una carpeta oculta llamada .git) vive en tu computadora y con eso ya estas usando control de versiones. Pero, también podrías conectar el repositorio local con un repositorio remoto. En este curso vamos a utilizar GitHub para alojar repositorios remotos, pero hay otras opciones que podrías explorar, como GitLab.\nImaginemos que tenemos un repositorio local, hicimos cambios en un archivo y luego commits para guardar esa nueva versión. Ahora necesitamos enviar esos cambios al repositorio remoto (más adelante veremos cómo crear el repositorio remoto). Para ello empujamos (push en inglés) los commits al repositorio remoto y entonces, los dos repositorios están “actualizados”, tienen la misma versión de los archivos.\nLuego, otra persona de tu equipo hace un cambio en un archivo en su repositorio local y lo sube al repositorio remoto. Ahora, tu repositorio local está “desactualizado” y necesitas descargar esos nuevos commits del repositorio remoto a tu computadora. Necesitas hacer pull.\n\n\n\nModelo conceptual de un flujo de trabajo utilizando proyectos RStudio y git. Los archivos se añaden al área de preparación y luego se envían al repositorio local. Puedes enviar commits al repositorio remoto y bajar nuevos commits a tu computadora.\n\n\nHerramientas como GitHub también incluyen funciones que te ayudan a colaborar y gestionar repositorios. Por ejemplo, puedes modificar archivos y hacer commits con esos cambios utilizando la interfaz web.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#preséntate-con-git",
    "href": "04_git-1.html#preséntate-con-git",
    "title": "5  git para trabajar individualmente",
    "section": "5.5 Preséntate con Git",
    "text": "5.5 Preséntate con Git\nAntes de crear tu primer repositorio tenes que asegurarte de que git y RStudio se entienden y de que git te conoce. Si seguiste las instrucciones instrucciones previas al curso seguro que RStudio, git y GitHub se hablan entre sí.\n\nPodés comprobar que RStudio “sabe” donde está git yendo a Tools --&gt; Global Options --&gt; Git/SVN. Allí deberías encontrar la ruta en tu computadora a la instalación de git.\n\nPara presentarte con git, es decir, para que reconozca tu nombre y correo electrónico, puedes utilizar el comando use_git_config del paquete usethis.\nlibrary(usethis) \nuse_git_config(user.name = \"Juan Perez\",\n               user.email = \"juan@ejemplo.org\")\nSustituyéndolo por tu nombre y el correo electrónico asociado a tu cuenta de GitHub.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#creando-un-nuevo-repositorio",
    "href": "04_git-1.html#creando-un-nuevo-repositorio",
    "title": "5  git para trabajar individualmente",
    "section": "5.6 Creando un nuevo repositorio",
    "text": "5.6 Creando un nuevo repositorio\nHay muchas formas de iniciar un nuevo repositorio, localmente en tu computadora utilizando la terminal, desde GitHub (o sus amigos) ¡o desde RStudio!. Aca te mostraremos cómo crear un repositorio desde GitHub, asociarlo a un proyecto de RStudio y trabajar con él. Pero tené en cuenta que hay muchas otras formas de trabajar con git.\n\n1. Creá un repositorio online.\n\nEntrá en github.com e inicia sesión.\nEn la esquina superior derecha, hacé click en el botón “+” y luego en “New repository”.\n\nA continuación completá la información del repositorio:\n\nRepository template: No template.\nRepository name: como quieras llamar a tu nuevo proyecto.\nDescription: Una descripción breve del proyecto. Escribila para los humanos.\nVisibilidad: Public.\nInitialize this repository with: nada (podemos configurarlo todo desde R).\n\nAntes de volver a RStudio, copia la url del repositorio. Por ejemplo https://github.com/paocorrales/myrepo.git\n\n\n2. En RStudio, inicia un nuevo Proyecto:\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio” pegá la URL de tu nuevo repositorio de GitHub, tiene que tener esta pinta: https://github.com/paocorrales/myrepo.git.\nElejí la carpeta en tu disco donde querés crear el proyecto.\nElejí “Open in new sesion”.\nY haz clic en “Create project”.\n\n\nLa nueva carpeta en tu computadora será un repositorio git, vinculado a un repositorio remoto de GitHub y un proyecto de RStudio al mismo tiempo. Este flujo de trabajo también se asegura de que toda la configuración entre los repositorios local y remoto se realice correctamente.\nTambién agrega un archivo llamado .gitignore que incluye una lista de archivos que no queremos sumar al repositorio (por ejemplo .Rhistory).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#cambios-locales",
    "href": "04_git-1.html#cambios-locales",
    "title": "5  git para trabajar individualmente",
    "section": "5.7 Cambios locales",
    "text": "5.7 Cambios locales\nEs hora de poner en práctica algunas de las cosas de las que hemos estado hablando.\n\nAdd, commit\n\nCreá un nuevo archivo RMarkdown y guardalo.\nAgregalo al área de preparación con add y luego hace un commit. ¡Vas a tener que pensar un mensaje descriptivo!\nHace un cambio en el archivo, puede ser cualquier cosa. Guardalo.\nRepetí el paso 2.\n\n\n\n\nPanel Git con 3 archivos sin seguimiento.\n\n\n\n\n\nPanel Git con 3 archivos con seguimiento añadidos al área de preparación.\n\n\n\n\n\nInterfaz RStudio para ver las diferencias entre archivos, escribir el mensaje para el commit y enviarlo al repositorio remoto.\n\n\n\nSi todo salió bien, empezaste a rastrear archivos, hiciste cambios y commits para guardar esa versión en el repositorio local. Puede que veas un mensaje en la pestaña de git diciendo que el repositorio local “is ahead of ’origin/master` by 2 commits”. No verás ningún cambio en GitHub hasta que hagas push y envíes esos commits al repositorio remoto. Podés hacer esto al final del día si preferis, pero si trabajas con otras personas puede ser una buena idea hacer push luego de cada commit.\n\n¡Push!\n\nAhora, hacé push para enviar los commits al repositorio remoto utilizando el botón con la flecha verde apuntando hacia arriba.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#cambios-remotos",
    "href": "04_git-1.html#cambios-remotos",
    "title": "5  git para trabajar individualmente",
    "section": "5.8 Cambios remotos",
    "text": "5.8 Cambios remotos\nVolvamos a GitHub. Si actualizas la página, ahora verás los archivos que acabas sumar al repositorio o modificar. Hagamos click en “Commits” para ver la historia del repositorio. Desde esta página, podés explorar el repositorio en el “estado” en el que estaba con cada commit y ver las diferencias entre las distintas versiones.\nAhora, podemos intentar hacer cambios aquí.\n\nCrear un README\n\nEn la página principal, hacé click en el botón verde que dice “Add a README”.\nAgregá algo en el archivo. Los README suelen estar escritos en Markdown y contienen información sobre el repositorio.\nAl final de la página añadí un mensaje y hacé click en “Confirm changes…”.\nVolvé a la página principal para ver el README.\n\n\nEl nuevo archivo y los cambios que hagas en GitHub sólo estarán en el repositorio remoto hasta que hagas un pull en el repositorio local. Si realizas cambios en el repositorio local mientras no está actualizado, podés encontrarte con conflictos cuando intentes unir las 2 versiones, lo que suele generar dolores de cabeza. Esto ocurre cuando la versión de un archivo en el repositorio local no es compatible con su versión en el repositorio remoto. En esos casos, git no puede decidir qué versión es la correcta y tenés que hacerlo vos.\nPara evitar este problema (lo más posible), tenes que hacer un pull antes de empezar a hacer cualquier otra cosa. La mayoría de las veces RStudio mostrará el mensaje “Already up to date”, pero es bueno hacerlo un hábito.\n\nPull desde GitHub\n\nVolvé a RStudio.\nRevisá panel de Git.\nHacé click en la flecha azul que dice “Pull”.\nRevisá el archivo README en la pestaña Archivos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#anatomía-de-un-repositorio-de-github",
    "href": "04_git-1.html#anatomía-de-un-repositorio-de-github",
    "title": "5  git para trabajar individualmente",
    "section": "5.9 Anatomía de un repositorio de GitHub",
    "text": "5.9 Anatomía de un repositorio de GitHub\n\nArchivos README. Utilizá un README.md para explicar de que se trata es tu proyecto y cómo utilizarlo. README.md es el archivo que se muestra automáticamente cuando abrís un repositorio de GitHub.\nLicencia. La licencia le indica a las personas cómo puede utilizar el contenido de tu repositorio. Generalmente, utilizamos licencias permisivas para que las personas pueda utilizar los materiales de cualquier manera. Algunos ejemplos son la Licencia MIT o Apache. Podés revisar algunos recursos extra:\n\nElejí una licencia para proyectos de código.\nLicencias de software en lenguaje sencillo: explica la jerga legal de las licencias en términos sencillos\n\nGuía para colaborar. Un archivo llamado CONTRIBUTING.md que incluye las instrucciones que personas que quieren conlaborar en tu proyecto sepan lo que deben hacer si quieren ayudarte.\nCódigo de conducta. Los buenos proyectos tienen códigos de conducta para garantizar un ambiente amigable donde las personas pueden colaborar. Github tiene atajos para agregar Código de Conducta facilmente.\nIssues. Te permiten gestionar el proyecto, discutir problemas y mejoras con otras personas.\n\n\nPara practicar git y de paso lo que estuvimos viendo sobre manipulación de datos vamos a usar GitHub Classroom.\n¿Cómo funciona?\nPreparamos repositorios con distintos ejercicios para que resuelvan. Cada persona tendrá su repositorio para trabajar de manera individual, aunque siempre pueden resolver los ejercicios en grupos (pequeños!, 2 o 3 personas)\nEn el campus encontrarás las instrucciones para acceder a tu repositorio.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "05_graficos.html",
    "href": "05_graficos.html",
    "title": "\n6  Graficado datos\n",
    "section": "",
    "text": "6.0.1 Primera capa: el área del gráfico\nCómo siempre será necesario cargar los paquetes que vamos a usar y ya que estamos los datos con los que venimos trabajando:\nlibrary(ggplot2)\npaises &lt;- datos::paises\n\nstr(paises)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ pais             : Factor w/ 142 levels \"Afganistán\",\"Albania\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continente       : Factor w/ 5 levels \"África\",\"Américas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ anio             : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ esperanza_de_vida: num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ poblacion        : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ pib_per_capita   : num [1:1704] 779 821 853 836 740 ...\nLa función principal de ggplot2 es justamente ggplot() que nos permite iniciar el gráfico y además definir las características globales. El primer argumento de esta función serán los datos que queremos visualizar, siempre en un data.frame. En este caso usamos paises.\nEl segundo argumento se llama mapping justamente porque mapea o dibuja los ejes del gráfico y siempre va acompañado de la función aes(). La función aes() recibe las propiedades estéticas del gráfico (o aesthetic en inglés) a partir de las variables (o columnas) del data.frame que estamos usando. En este caso le indicamos que en el eje x querremos graficar la variable pib_per_capita y en eje y la variable esperanza_de_vida.\nPero esta sola función no es suficiente, solo genera la primera capa: el área del gráfico.\nggplot(data = paises, mapping = aes(x = pib_per_capita, y = esperanza_de_vida))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#gráficos-de-frecuencias",
    "href": "05_graficos.html#gráficos-de-frecuencias",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.1 Gráficos de frecuencias",
    "text": "6.1 Gráficos de frecuencias\nEste es un gráfico de barras construido usando la función geom_bar(). En el eje x muestra el corte de los diamantes y en el eje y la cantidad (count en inglés) de diamantes en cada categoría. Pero diamantes no tiene una variable que se llame count y tampoco la generamos nosotros. ¡Es calculada internamente por ggplot2!\n\nggplot(data = diamantes, aes(x = corte)) +\n  geom_bar()\n\n\n\n\n\n\n\nCómo el gráfico de barras, también podemos graficar histogramas con geom_histogram() y polígonos de frecuencia con geom_density() para visualizar la cantidad de observaciones que caen en cada categoría (si la variable es discreta como el caso del corte de los diamantes) o rango de valores (para variables continuas).\nUn ejemplo de variable continua es el precio de los diamantes, veamos como se ve un histograma y de paso le cambiamos el color a las barras, pero ojo, solo al borde.\n\nggplot(diamantes, aes(precio)) +\n  geom_histogram(fill = \"darkorange\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n¿Notaste el mensaje que devuelve el gráfico?\n`stat_bin() using bins = 30. Pick better value with binwidth.`\nEsta geometría tiene dos argumentos importantes bins y binwidth. Cambiá el valor de alguno de los dos argumentos y volvé a generar el gráfico, ¿que rol juegan los argumentos?\nTambién podés revisar la documentación.\n\nAdemás de contar la cantidad de elementos, ggplot2 puede calcular muchas otras transformaciones sobre los datos. Por ejemplo si quisiéramos el porcentaje o la proporción que le corresponde a cada categoría de corte respecto del total podemos hacerlo mapeando esa transformación prop al eje y con la función after_stat().\n\nggplot(data = diamantes, aes(x = corte)) +\n  geom_bar(aes(y = after_stat(prop), group = 1))\n\n\n\n\n\n\n\nFijate que la variable prop no es una columna de diamantes sino que es el nombre de una variable computada por geom_bar(), por eso hay que rodearla de la función stat(). El nombre de las variables computadas por cada geoms está en su documentación (abajo de todo, antes de los ejemplos).\nAhora podríamos decir que el 40% de los diamantes en la base de datos tienen un corte ideal. Además de la función after_stat() agregamos group = 1 y esto no fue sin querer. Probá correr el gráfico sin ese argumento.\nAl incluir group = 1, ggplot2 junta todas las observaciones en un único grupo (con el valor 1) y calcula la proporción o el porcentaje que representa cada corte respecto del total de diamantes. Si no incluimos eso, ggplot2 asumirá que cada categoría de corte es un grupo independiente y el cálculo del porcentaje también lo hará por separado.\n\nLas geometrías geom_col() y geom_bar() tienen un argumento llamado position que afecta como se organizan las barras particularmente cuando mapeamos una tercer variable al relleno. Por ejemplo:\n\nggplot(data = diamantes) +\n  geom_bar(aes(x = corte, fill = claridad))\n\n\n\n\n\n\n\n\nRevisá la documentación de estas geometrías e identificá las distintas opciones que puede tomar el argumento position.\nProbá cada uno y comparalos para ver las diferencias.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#gráficos-de-caja",
    "href": "05_graficos.html#gráficos-de-caja",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.2 Gráficos de caja",
    "text": "6.2 Gráficos de caja\nLos diagramas de caja, mejor conocidos como boxplots calculan un resumen robusto de la distribución y luego muestran una caja con formato especial.\nLa línea central de la caja corresponde a la mediana (el valor que toma el dato central) y los extremos de la caja son los cuartiles 1 y 3, definiendo así el rango intercuartil (IQR). Los extremos están definidos como el valor observado que no esté más lejos de 1.5*IQR de la mediana y los puntos son los las observaciones que se escapan de ese rango, que pueden ser considerados outliers o valores extremos.\n\nggplot(diamantes, aes(claridad, precio)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nLos boxplot dan muchísima información sobre los datos pero al mismo tiempo esconden la cantidad de observaciones que se usaron para generarlos y en particular cual es la frecuencia a lo largo del eje y. Por esta razón también existen geom_violin() y geom_jitter().\n\n\nVolvé a graficar la distribución del precio para cada tipo de claridad pero ahora usando geom_violin() y geom_jitter().\n¿Qué ventajas y desventajas encuentran respecto de geom_boxplot()?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCuando nuestra base de datos es muy grande corremos el riesgo de que los elementos del gráfico estén tan juntos que se solapen y no se vean. Esto se conoce como overplotting. La base de datos diamantes tiene 53940 observaciones y al graficar un punto por cada una, aún si están separados por la claridad, quedan superpuestos.\nPara resolver este problema se suele modificar la estética de los elementos, cambiando el tamaño o size para que ocupen menos lugar y se vean mejor, cambiando la forma o shape por alguna que no tenga relleno y permita ver los elementos que hay atrás o modificando la transparencia o alpha por la misma razón. En bases de datos tan grandes como la de diamantes, muchas veces hay que utilizar varios de estos recursos.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#graficando-en-múltiples-paneles",
    "href": "05_graficos.html#graficando-en-múltiples-paneles",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.3 Graficando en múltiples paneles",
    "text": "6.3 Graficando en múltiples paneles\nVimos que es posible graficar más de dos variables en un gráfico mapeando una variable al color o por ejemplo el tipo de línea o linetype\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\nEn este caso no solo visualizamos la relación entre el precio y el quilate del diamante, también podemos ver que rol juega el color. También podríamos haber intentando resolver el problema generando un gráfico por cada color filtrando las observaciones correspondientes.\n\ndiamantes %&gt;% \n  filter(color == \"D\") %&gt;% \n  ggplot(aes(quilate, precio)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\nPero sería muchísimo trabajo si tenemos que hacer esto para cada una de las 7 categorías de color. La buena noticia es que ggplot2 tiene un par de funciones justo para resolver este problema:\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color)) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\nEsta nueva capa con facet_wrap() divide al gráfico inicial en 7 paneles o facets, uno por cada color. Esta función requiere saber que variable será la responsable de separar los paneles y para eso se usa la notación de funciones de R: ~color. Esto se lee como generar paneles “en función del color”.\n¿Y si quisiéramos generar paneles a partir de 2 variables? Para eso existe facet_grid(). En este gráfico generamos paneles viendo la “relación entre el corte y el color” y por ejemplo en el primer panel arriba a la izquierda podremos observar los diamantes que son al mismo tiempo de color D y corte Regular. En este caso mapear la variable color al color de los diamantes no parece ser necesario ya que cada columna ya nos permite identificar eso, sin embargo en algunos casos ayuda a leer el gráfico más rápido.\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color)) +\n  facet_grid(corte~color)\n\n\n\n\n\n\n\n\nGenerá boxplots para analizar como se comporta el precio según la claridad para cada tipo de corte como se ve acá.\n\n\n\n\n\n\n\n\n\n\n6.3.1 Construyendo un paquete de R paso a paso\n\nSigamos analizando los datos de estaciones meteorológicas.\n\nGraficá la temperatura de abrico para la estación NH0437 (tendrías que filtrar los datos para quedarte solo con esta estación). Sumá una regresión linea, ¿se mentiene constante la temperatura media con el tiempo o cambia?\n\n\nCalculá el promedio mensual de la temperatura de abrigo para cada estación y gráfica el resultado. El gráfico tendría que tener más o menos esta pinta:\n\n\n\n\n\n\n\n\n\n\n¿Cuál es la relación entre la temperatura de abrigo y la humedad? Hacé un gráfico de puntos que muestre la relación, podés sumar un suavisado (opcional). Para la humedad utilizá la varable humedad_media_8_14_20.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html",
    "href": "06_manipulacion-2.html",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "",
    "text": "7.1 De ancho a largo con pivot_longer()\nAntes, usamos el set de datos de paises que viene en el paquete datos. Vamos a usar los datos originales que tienen un formato ancho.\npaises_ancho &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/paises_ancho.csv\")\n\nRows: 142 Columns: 38\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): pais, continente\ndbl (36): esperanza_de_vida-1952, esperanza_de_vida-1957, esperanza_de_vida-...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npaises_ancho\n\n# A tibble: 142 × 38\n   pais       continente `esperanza_de_vida-1952` `esperanza_de_vida-1957`\n   &lt;chr&gt;      &lt;chr&gt;                         &lt;dbl&gt;                    &lt;dbl&gt;\n 1 Afganistán Asia                           28.8                     30.3\n 2 Albania    Europa                         55.2                     59.3\n 3 Argelia    África                         43.1                     45.7\n 4 Angola     África                         30.0                     32.0\n 5 Argentina  Américas                       62.5                     64.4\n 6 Australia  Oceanía                        69.1                     70.3\n 7 Austria    Europa                         66.8                     67.5\n 8 Baréin     Asia                           50.9                     53.8\n 9 Bangladesh Asia                           37.5                     39.3\n10 Bélgica    Europa                         68                       69.2\n# ℹ 132 more rows\n# ℹ 34 more variables: `esperanza_de_vida-1962` &lt;dbl&gt;,\n#   `esperanza_de_vida-1967` &lt;dbl&gt;, `esperanza_de_vida-1972` &lt;dbl&gt;,\n#   `esperanza_de_vida-1977` &lt;dbl&gt;, `esperanza_de_vida-1982` &lt;dbl&gt;,\n#   `esperanza_de_vida-1987` &lt;dbl&gt;, `esperanza_de_vida-1992` &lt;dbl&gt;,\n#   `esperanza_de_vida-1997` &lt;dbl&gt;, `esperanza_de_vida-2002` &lt;dbl&gt;,\n#   `esperanza_de_vida-2007` &lt;dbl&gt;, `poblacion-1952` &lt;dbl&gt;, …\nEsta tabla, increíblemente ancha, es muy difícil de manejar. Por ejemplo, es imposible hacer una serie de tiempo de una variable, o calcular el promedio por variable y país; ni hablar de calcular una regresión lineal.\nPara convertirlo en una tabla más larga, se usa pivot_longer() (“longer” es “más largo” en inglés):\npaises_largo &lt;- pivot_longer(paises_ancho,\n                             cols = c(starts_with('pob'), \n                                      starts_with('esperanza'), \n                                      starts_with('pib_per')),\n                             names_to = \"variable_anio\", \n                             values_to = \"valor\"\n)\npaises_largo\n\n# A tibble: 5,112 × 4\n   pais       continente variable_anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt;\n 1 Afganistán Asia       poblacion-1952  8425333\n 2 Afganistán Asia       poblacion-1957  9240934\n 3 Afganistán Asia       poblacion-1962 10267083\n 4 Afganistán Asia       poblacion-1967 11537966\n 5 Afganistán Asia       poblacion-1972 13079460\n 6 Afganistán Asia       poblacion-1977 14880372\n 7 Afganistán Asia       poblacion-1982 12881816\n 8 Afganistán Asia       poblacion-1987 13867957\n 9 Afganistán Asia       poblacion-1992 16317921\n10 Afganistán Asia       poblacion-1997 22227415\n# ℹ 5,102 more rows\nEl primer argumento depivot_longer() es la tabla que va a modificar: paises_ancho. El segundo argumento se llama cols y es un vector con las columnas que tienen los valores a “alargar”. Podría ser un vector escrito a mano (algo como c(\"pib_per_capita-1952\", \"pib_per_capita-1957\"...)) pero con más de 30 columnas, escribir todo eso sería tedioso y probablemente estaría lleno de errores. Por eso tidyr provee funciones de ayuda para seleccionar columnas en base a patrones. El código de arriba usa starts_with() que, como su nombre en inglés lo indica, selecciona las columnas que empiezan con una determinada cadena de caracteres. El vector c(starts_with('pob'), starts_with('esperanza'), starts_with('pib_per')) le dice a pivot_longer() que seleccione las columnas que empieza con “pob”, las que empiezan con “esperanza” y las que empiezan con “pib_per”.\nEl tercer y cuarto argumento son los nombres de las columnas de “nombre” y de “valor” que va a tener la nueva tabla. Como la nueva columna de identificación tiene los datos de la variable y el año a medir, “variable_anio” es un buen nombre. Y la columna de valor va a tener… bueno, el valor.\nTomate un momento para visualizar lo que acaba de pasar. La tabla ancha tenía un montón de columnas con distintos datos. Ahora estos datos están uno arriba de otro en la columna “valor”, pero para identificar el nombre de la columna de la cual vinieron, se agrega la columna “variable_anio”.\nLa columna variable_anio todavía no es muy útil porque contiene 2 datos, la variable (población, expectativa de vida o PBI per cápita) y el año. Sería mejor separar esta información en dos columnas llamadas “variable” y “anio”. Para eso está la función separate().\npaises_largo &lt;- separate_wider_delim(paises_largo, \n         col = variable_anio, \n         delim = \"-\",\n         names = c(\"variable\", \"anio\"))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable  anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion 1952   8425333\n 2 Afganistán Asia       poblacion 1957   9240934\n 3 Afganistán Asia       poblacion 1962  10267083\n 4 Afganistán Asia       poblacion 1967  11537966\n 5 Afganistán Asia       poblacion 1972  13079460\n 6 Afganistán Asia       poblacion 1977  14880372\n 7 Afganistán Asia       poblacion 1982  12881816\n 8 Afganistán Asia       poblacion 1987  13867957\n 9 Afganistán Asia       poblacion 1992  16317921\n10 Afganistán Asia       poblacion 1997  22227415\n# ℹ 5,102 more rows\nEl primer argumento, como siempre, es la tabla a procesar. El segundo, col, es la columna a separar en dos (o más) columnas nuevas. El segundo argumento indica cómo se separan los elementos, en este caso con guíon “-”. El tercero, names es el nombre de las nuevas columnas que separate_wider_delim() va a crear.\nY ya casi. Pero fijate que debajo de la columna anio dice &lt;chr&gt;; eso significa que el tipo de la columna es caracter, pero los años son números. Usando mutate() podemos convertir la columna anio a entero usando as.integer():\npaises_largo &lt;- mutate(paises_largo, \n                       anio = as.integer(anio))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable   anio    valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion  1952  8425333\n 2 Afganistán Asia       poblacion  1957  9240934\n 3 Afganistán Asia       poblacion  1962 10267083\n 4 Afganistán Asia       poblacion  1967 11537966\n 5 Afganistán Asia       poblacion  1972 13079460\n 6 Afganistán Asia       poblacion  1977 14880372\n 7 Afganistán Asia       poblacion  1982 12881816\n 8 Afganistán Asia       poblacion  1987 13867957\n 9 Afganistán Asia       poblacion  1992 16317921\n10 Afganistán Asia       poblacion  1997 22227415\n# ℹ 5,102 more rows",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#de-ancho-a-largo-con-pivot_longer",
    "href": "06_manipulacion-2.html#de-ancho-a-largo-con-pivot_longer",
    "title": "7  Manipulación de datos ordenados II",
    "section": "7.1 De ancho a largo con pivot_longer()",
    "text": "7.1 De ancho a largo con pivot_longer()\nAntes, usamos el set de datos de paises que viene en el paquete datos. Vamos a usar los datos originales que tienen un formato ancho.\n\npaises_ancho &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/paises_ancho.csv\")\n\nRows: 142 Columns: 38\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): pais, continente\ndbl (36): esperanza_de_vida-1952, esperanza_de_vida-1957, esperanza_de_vida-...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npaises_ancho\n\n# A tibble: 142 × 38\n   pais       continente `esperanza_de_vida-1952` `esperanza_de_vida-1957`\n   &lt;chr&gt;      &lt;chr&gt;                         &lt;dbl&gt;                    &lt;dbl&gt;\n 1 Afganistán Asia                           28.8                     30.3\n 2 Albania    Europa                         55.2                     59.3\n 3 Argelia    África                         43.1                     45.7\n 4 Angola     África                         30.0                     32.0\n 5 Argentina  Américas                       62.5                     64.4\n 6 Australia  Oceanía                        69.1                     70.3\n 7 Austria    Europa                         66.8                     67.5\n 8 Baréin     Asia                           50.9                     53.8\n 9 Bangladesh Asia                           37.5                     39.3\n10 Bélgica    Europa                         68                       69.2\n# ℹ 132 more rows\n# ℹ 34 more variables: `esperanza_de_vida-1962` &lt;dbl&gt;,\n#   `esperanza_de_vida-1967` &lt;dbl&gt;, `esperanza_de_vida-1972` &lt;dbl&gt;,\n#   `esperanza_de_vida-1977` &lt;dbl&gt;, `esperanza_de_vida-1982` &lt;dbl&gt;,\n#   `esperanza_de_vida-1987` &lt;dbl&gt;, `esperanza_de_vida-1992` &lt;dbl&gt;,\n#   `esperanza_de_vida-1997` &lt;dbl&gt;, `esperanza_de_vida-2002` &lt;dbl&gt;,\n#   `esperanza_de_vida-2007` &lt;dbl&gt;, `poblacion-1952` &lt;dbl&gt;, …\n\n\n\n¿Notaste que en el código anterior no usaste library(readr) para cargar el paquete y luego leer? Con la notación paquete::funcion() podés acceder a las funciones de un paquete sin tener que cargarlo. Es una buena forma de no tener que cargar un montón de paquetes innecesarios si vas a correr una única función de un paquete pocas veces.\n\nEsta tabla, increíblemente ancha, es muy difícil de manejar. Por ejemplo, es imposible hacer una serie de tiempo de una variable, o calcular el promedio por variable y país; ni hablar de calcular una regresión lineal.\nPara convertirlo en una tabla más larga, se usa pivot_longer() (“longer” es “más largo” en inglés):\n\npaises_largo &lt;- pivot_longer(paises_ancho,\n                             cols = c(starts_with('pob'), \n                                      starts_with('esperanza'), \n                                      starts_with('pib_per')),\n                             names_to = \"variable_anio\", \n                             values_to = \"valor\"\n)\npaises_largo\n\n# A tibble: 5,112 × 4\n   pais       continente variable_anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt;\n 1 Afganistán Asia       poblacion-1952  8425333\n 2 Afganistán Asia       poblacion-1957  9240934\n 3 Afganistán Asia       poblacion-1962 10267083\n 4 Afganistán Asia       poblacion-1967 11537966\n 5 Afganistán Asia       poblacion-1972 13079460\n 6 Afganistán Asia       poblacion-1977 14880372\n 7 Afganistán Asia       poblacion-1982 12881816\n 8 Afganistán Asia       poblacion-1987 13867957\n 9 Afganistán Asia       poblacion-1992 16317921\n10 Afganistán Asia       poblacion-1997 22227415\n# ℹ 5,102 more rows\n\n\nEl primer argumento depivot_longer() es la tabla que va a modificar: paises_ancho. El segundo argumento se llama cols y es un vector con las columnas que tienen los valores a “alargar”. Podría ser un vector escrito a mano (algo como c(\"pib_per_capita-1952\", \"pib_per_capita-1957\"...)) pero con más de 30 columnas, escribir todo eso sería tedioso y probablemente estaría lleno de errores. Por eso tidyr provee funciones de ayuda para seleccionar columnas en base a patrones. El código de arriba usa starts_with() que, como su nombre en inglés lo indica, selecciona las columnas que empiezan con una determinada cadena de caracteres. El vector c(starts_with('pob'), starts_with('esperanza'), starts_with('pib_per')) le dice a pivot_longer() que seleccione las columnas que empieza con “pob”, las que empiezan con “esperanza” y las que empiezan con “pib_per”.\n\nEstas funciones accesorias para seleccionar muchas funciones se llaman “tidyselect”. Si querés leer más detalles de las distintas formas que podés seleccionar variables leé la documentación usando ?tidyselect::language.\n\nEl tercer y cuarto argumento son los nombres de las columnas de “nombre” y de “valor” que va a tener la nueva tabla. Como la nueva columna de identificación tiene los datos de la variable y el año a medir, “variable_anio” es un buen nombre. Y la columna de valor va a tener… bueno, el valor.\nTomate un momento para visualizar lo que acaba de pasar. La tabla ancha tenía un montón de columnas con distintos datos. Ahora estos datos están uno arriba de otro en la columna “valor”, pero para identificar el nombre de la columna de la cual vinieron, se agrega la columna “variable_anio”.\n\n\n\nProceso de largo a ancho\n\n\nLa columna variable_anio todavía no es muy útil porque contiene 2 datos, la variable (población, expectativa de vida o PBI per cápita) y el año. Sería mejor separar esta información en dos columnas llamadas “variable” y “anio”. Para eso está la función separate().\n\npaises_largo &lt;- separate_wider_delim(paises_largo, \n         col = variable_anio, \n         delim = \"-\",\n         names = c(\"variable\", \"anio\"))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable  anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion 1952   8425333\n 2 Afganistán Asia       poblacion 1957   9240934\n 3 Afganistán Asia       poblacion 1962  10267083\n 4 Afganistán Asia       poblacion 1967  11537966\n 5 Afganistán Asia       poblacion 1972  13079460\n 6 Afganistán Asia       poblacion 1977  14880372\n 7 Afganistán Asia       poblacion 1982  12881816\n 8 Afganistán Asia       poblacion 1987  13867957\n 9 Afganistán Asia       poblacion 1992  16317921\n10 Afganistán Asia       poblacion 1997  22227415\n# ℹ 5,102 more rows\n\n\nEl primer argumento, como siempre, es la tabla a procesar. El segundo, col, es la columna a separar en dos (o más) columnas nuevas. El segundo argumento indica cómo se separan los elementos, en este caso con guíon “-”. El tercero, names es el nombre de las nuevas columnas que separate_wider_delim() va a crear.\nY ya casi. Pero fijate que debajo de la columna anio dice &lt;chr&gt;; eso significa que el tipo de la columna es caracter, pero los años son números. Usando mutate() podemos convertir la columna anio a entero usando as.integer():\n\npaises_largo &lt;- mutate(paises_largo, \n                       anio = as.integer(anio))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable   anio    valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion  1952  8425333\n 2 Afganistán Asia       poblacion  1957  9240934\n 3 Afganistán Asia       poblacion  1962 10267083\n 4 Afganistán Asia       poblacion  1967 11537966\n 5 Afganistán Asia       poblacion  1972 13079460\n 6 Afganistán Asia       poblacion  1977 14880372\n 7 Afganistán Asia       poblacion  1982 12881816\n 8 Afganistán Asia       poblacion  1987 13867957\n 9 Afganistán Asia       poblacion  1992 16317921\n10 Afganistán Asia       poblacion  1997 22227415\n# ℹ 5,102 more rows\n\n\n\nJuntá todos los pasos anteriores en una sola cadena de operaciones usando |&gt;.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#de-largo-a-ancho-con-pivot_wider",
    "href": "06_manipulacion-2.html#de-largo-a-ancho-con-pivot_wider",
    "title": "7  Manipulación de datos ordenados II",
    "section": "7.2 De largo a ancho con pivot_wider()",
    "text": "7.2 De largo a ancho con pivot_wider()\nAhora la variable paises_largo está en el formato más largo posible. Tiene 5 columnas, de las cuales sólo una es la columnas con valores. Pero con los datos así no podrías hacer un gráfico de puntos que muestre la relación entre el PBI per cápita y la expectativa de vida como en la sección de gráficos. Fijate que los valores de la columna valor no tienen todos las mismas unidades, por lo que operar con ese vector podría dar resultados sin sentido. Muchas veces es conveniente y natural tener los datos en un formato intermedio en donde hay múltiples columnas con los valores de distintas variables observadas.\nPasa “ensanchar” una tabla está la función pivot_wider() (“wider” es “más ancha” en inglés) y el código para conseguir este formato intermedio es:\n\npaises_medio &lt;- pivot_wider(paises_largo, names_from = variable, values_from = valor)\npaises_medio\n\n# A tibble: 1,704 × 6\n   pais       continente  anio poblacion esperanza_de_vida pib_per_capita\n   &lt;chr&gt;      &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt;             &lt;dbl&gt;          &lt;dbl&gt;\n 1 Afganistán Asia        1952   8425333              28.8           779.\n 2 Afganistán Asia        1957   9240934              30.3           821.\n 3 Afganistán Asia        1962  10267083              32.0           853.\n 4 Afganistán Asia        1967  11537966              34.0           836.\n 5 Afganistán Asia        1972  13079460              36.1           740.\n 6 Afganistán Asia        1977  14880372              38.4           786.\n 7 Afganistán Asia        1982  12881816              39.9           978.\n 8 Afganistán Asia        1987  13867957              40.8           852.\n 9 Afganistán Asia        1992  16317921              41.7           649.\n10 Afganistán Asia        1997  22227415              41.8           635.\n# ℹ 1,694 more rows\n\n\nNuevamente el primer argumento es la tabla original. El segundo, names_from es la columna cuyos valores únicos van a convertirse en nuevas columnas. La columna variable tiene los valores \"población\", \"esperanza_de_vida\" y \"pib_per_capita\" y entonces la tabla nueva tendrá tres columnas con esos nombres. El tercer argumento, values_from, es la columna de la cual sacar los valores.\nPara volver al formato más ancho, basta con agregar más columnas en el argumento names_from:\n\npivot_wider(paises_largo, \n            names_from = c(variable, anio), \n            names_sep = \"-\",\n            values_from = valor)\n\n# A tibble: 142 × 38\n   pais       continente `poblacion-1952` `poblacion-1957` `poblacion-1962`\n   &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;\n 1 Afganistán Asia                8425333          9240934         10267083\n 2 Albania    Europa              1282697          1476505          1728137\n 3 Argelia    África              9279525         10270856         11000948\n 4 Angola     África              4232095          4561361          4826015\n 5 Argentina  Américas           17876956         19610538         21283783\n 6 Australia  Oceanía             8691212          9712569         10794968\n 7 Austria    Europa              6927772          6965860          7129864\n 8 Baréin     Asia                 120447           138655           171863\n 9 Bangladesh Asia               46886859         51365468         56839289\n10 Bélgica    Europa              8730405          8989111          9218400\n# ℹ 132 more rows\n# ℹ 33 more variables: `poblacion-1967` &lt;dbl&gt;, `poblacion-1972` &lt;dbl&gt;,\n#   `poblacion-1977` &lt;dbl&gt;, `poblacion-1982` &lt;dbl&gt;, `poblacion-1987` &lt;dbl&gt;,\n#   `poblacion-1992` &lt;dbl&gt;, `poblacion-1997` &lt;dbl&gt;, `poblacion-2002` &lt;dbl&gt;,\n#   `poblacion-2007` &lt;dbl&gt;, `esperanza_de_vida-1952` &lt;dbl&gt;,\n#   `esperanza_de_vida-1957` &lt;dbl&gt;, `esperanza_de_vida-1962` &lt;dbl&gt;,\n#   `esperanza_de_vida-1967` &lt;dbl&gt;, `esperanza_de_vida-1972` &lt;dbl&gt;, …\n\n\nEn esta llamada también está el argumento names_sep, que determina el caracter que se usa para crear el nombre de las nuevas columnas.\n\n\nCreá una nueva tabla, llamada paises_superduper_ancho que tenga una columna para cada variable, anio y país. (Consejo: la tabla final tiene que tener 5 filas).\n¿Cómo es la tabla más ancha posible que podés generar con estos datos? ¿Cuántas filas y columnas tiene?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#uniendo-tablas",
    "href": "06_manipulacion-2.html#uniendo-tablas",
    "title": "7  Manipulación de datos ordenados II",
    "section": "7.3 Uniendo tablas",
    "text": "7.3 Uniendo tablas\nHasta ahora todo lo que usaste de dplyr involucra trabajar y modificar con una sola tabla a la vez, pero es muy común tener dos o más tablas con datos relacionados. En ese caso, tenemos que unir estas tablas. a partir de una o más variables en común o keys. En el mundo de dplyr hay que usar la familia de funciones *_join(). Hay una función cada tipo de unión que queramos hacer.\nAsumiendo que querés unir dos data.frames o tablas x e y que tienen en común una variable A:\n\n\nfull_join(): devuelve todas las filas y todas las columnas de ambas tablas x e y. Cuando no coinciden los elementos en x o y, devuelve NA (dato faltante). Esto significa que no se pierden filas de ninguna de las dos tablas aún cuando no hay coincidencia. Está es la manera más segura de unir tablas, para no perder datos.\nleft_join(): devuelve todas las filas de x y todas las columnas de x e y. Las filas en x que no tengan coincidencia con y tendrán NA en las nuevas columnas. Si hay múltiples coincidencias entre xe y, devuelve todas las coincidencias posibles.\nright_join(): es igual que left_join() pero intercambiando el orden de x e y. En otras palabras, right_join(x, y) es idéntico a left_join(y, x).\ninner_join(): devuelve todas las filas de x donde hay coincidencias con y y todas las columnas de x e y. Si hay múltiples coincidencias entre x e y, entonces devuelve todas las coincidencias. Esto significa que eliminará las filas (observaciones) que no coincidan en ambas tablas, lo que puede ser peligroso.\nanti_join(): devuelve todas las filas de x que no tienen coincidencias con y. Identifica observaciones no coincidentes entre dos conjunto de datos. Es muy util para encontrar datos faltantes o para eliminar datos duplicados.\n\n\nAhora vamos a seguir trabajando con las base de datos de paises pero nos vamos a quedar solo con las observaciones del 2007 y de paso unirlo a una nueva base de datos co2 que contiene información de la emisión de dióxido de carbono de cada país para ese mismo año.\n\npaises_2007 &lt;- datos::paises %&gt;% \n  filter(anio == 2007) \n\nco2_2007 &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/co2_2007.csv\")\nco2_2007\n\n# A tibble: 218 × 3\n   codigo_iso emision_co2 pais                  \n   &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;                 \n 1 ABW            27.9    Aruba                 \n 2 AFG             0.0854 Afghanistán           \n 3 AGO             1.20   Angola                \n 4 ALB             1.32   Albania               \n 5 AND             6.52   Andorra               \n 6 ARB             4.10   Mundo Árabe           \n 7 ARE            22.4    Emiratos Árabes Unidos\n 8 ARG             4.38   Argentina             \n 9 ARM             1.73   Armenia               \n10 ATG             5.14   Antigua y Barbuda     \n# ℹ 208 more rows\n\n\nEsta nueva tabla tiene 3 columnas: codigo_iso tiene el código ISO de 3 letras de (abreviaturas que se usan internacionalmente), emision_co2 tiene las emisiones anuales per cápita de CO2 en toneladas, pais tiene el nombre del país. Esta última columna también está presente en la tabla paises_2007 y es la que va a servir como variable llave para unir las dos tablas.\nPara unir las dos tablas, cualquier función join requiere cierta información:\n\nlas tablas a unir: son los dos primeros argumentos.\nqué variable o variables (se puede usar más de una!) usar para identificar coincidencias: el argumento by.\n\nUnamos paises_2007 y co2_2007 primero con full_join():\n\npaises_co2_2007 &lt;- full_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 241 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Afgan… Asia        2007              43.8  31889923           975. &lt;NA&gt;      \n 2 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 3 Argel… África      2007              72.3  33333216          6223. &lt;NA&gt;      \n 4 Angola África      2007              42.7  12420476          4797. AGO       \n 5 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 6 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 7 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 8 Baréin Asia        2007              75.6    708573         29796. &lt;NA&gt;      \n 9 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n10 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n# ℹ 231 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nSi miramos de cerca la tabla unida veremos un par de cosas:\n\nTodas las columnas de paises_2007 y de co2_2007 están presentes.\nTodas las observaciones están presentes, aún los países que están presentes en co2_2007 pero no en paises_2007 y viceversa. En esos casos ahora tenemos NA. Esto genera una tabla con 241 filas.\n\nEsta es la opción más segura si no sabemos si todas las observaciones de una tabla están presente en a otra.\nSi solo nos interesa conservar las filas de la tabla de la izquierda, en este caso paises_2007 entonces:\n\npaises_co2_2007 &lt;- left_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 142 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Afgan… Asia        2007              43.8  31889923           975. &lt;NA&gt;      \n 2 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 3 Argel… África      2007              72.3  33333216          6223. &lt;NA&gt;      \n 4 Angola África      2007              42.7  12420476          4797. AGO       \n 5 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 6 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 7 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 8 Baréin Asia        2007              75.6    708573         29796. &lt;NA&gt;      \n 9 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n10 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n# ℹ 132 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nAhora esperamos que la tabla resultante tenga la misma cantidad de filas que paises_2007 y efectivamente eso ocurre. Pero al mismo tiempo varios países en esa tabla no encontraron coincidencia en co2_2007 y por esa razón, la columna nueva columna emisiones_co2 tiene NA.\nSi quisiéramos quedarnos solo con las observaciones que están presentes en ambas tablas usamos inner_join().\n\npaises_co2_2007 &lt;- inner_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 119 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 2 Angola África      2007              42.7  12420476          4797. AGO       \n 3 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 4 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 5 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 6 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n 7 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n 8 Boliv… Américas    2007              65.6   9119152          3822. BOL       \n 9 Bosni… Europa      2007              74.9   4552198          7446. BIH       \n10 Botsw… África      2007              50.7   1639131         12570. BWA       \n# ℹ 109 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nEn este caso, perdemos las filas de co2_2007 que no encontraron coincidencia en paises_2007 y viceversa y la tabla resultante tiene aún menos filas (119).\nFinalmente, si quisieramos quedarnos con los paises para los cuales no tenemos datos de co2, o sea las observaciones en paises_2007 que no tienen coincidencia en co2_2007 usamos anti_join().\n\nsin_co2_2007 &lt;- anti_join(paises_2007, co2_2007)\n\nJoining with `by = join_by(pais)`\n\nsin_co2_2007\n\n# A tibble: 23 × 6\n   pais              continente  anio esperanza_de_vida poblacion pib_per_capita\n   &lt;fct&gt;             &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt;\n 1 Afganistán        Asia        2007              43.8  31889923           975.\n 2 Argelia           África      2007              72.3  33333216          6223.\n 3 Baréin            Asia        2007              75.6    708573         29796.\n 4 Benin             África      2007              56.7   8078314          1441.\n 5 Camboya           Asia        2007              59.7  14131858          1714.\n 6 República Centro… África      2007              44.7   4369038           706.\n 7 Comoras           África      2007              65.2    710960           986.\n 8 Congo             África      2007              55.3   3800610          3633.\n 9 Yibuti            África      2007              54.8    496374          2082.\n10 Guinea Bissau     África      2007              46.4   1472041           579.\n# ℹ 13 more rows\n\n\n\nEstuvimos trabajando con una parte de la base de datos de emisiones. Pero también está disponible co2_completo.csv que contiene las emisiones para distintos años. El objetivo es que unas paises y co2 teniendo en cuenta tanto el país como el año. Para eso:\n\nLee la base de datos co2_completo.csv en una nueva variable que se llame co2.\nRevisá el nombre de las variables en esta base de datos, ¿se llaman igual que las variables en paises?\nUní las dos tablas usando full_join(), tené en cuenta que ahora usamos dos variables llave pais y anio. Buscá en la documentación cómo indicarle eso a la función full_join().\n\nPodés descargar los datos desde https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/co2_completo.csv\n\n\n7.3.1 Construyendo un paquete de R paso a paso\n\nPivots!\nRecordás el ejercicio 3 de dplyr?\n\n¿Cuál es el promedio de la temperatura de abrigo a 150 cm en cada estación? ¿Y el desvío estandar? Pista: la mayoría de las funciones tienen un argumento para sacar los NA del cálculo, revisá la documentación de mean() y de sd().\n\n\nUsando las funciones pivot_ alargá el resultado anterior.\nA continuación volvé a ensanchar la tabla de tal manera que tengas columnas con los nombres de las estaciones y en las filas los valores de la media y el desvio estandar.\n\nuniones\nA la hora de analizar datos meteorológicos, tener en cuenta la ubicación y altitud de las estaciones donde se toman las mediciones es muy importane. Sin embargo eso no está incluido en los datos con los que venimos trabajando.\nEsta información son metadatos y suelen venir por separado (si tenemos suerte!). En este caso los tenemos y están disponibles en https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/metadatos_completos.csv.\n\nLee los metadatos\nIdentifica cuales son las variables clave, aquellas que son comunes entre los datos meteorológicos con los que venís trabajando y esta nueva tabla.\nUní los datos con joins. ¿Cuál es la mejor opción?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "07_funciones.html",
    "href": "07_funciones.html",
    "title": "\n8  Funciones\n",
    "section": "",
    "text": "8.1 Trabajando con funciones y otro código\nHasta ahora tenemos un proyecto con una determinada estructura de carpetas que nos permite ordenar nuestro trabajo. Además vimos en detalle como utilizar archivos .Rmd o .qmd autocontenidos, que incluyan el código y texto necesario para generar un análisis. Pero es posible que nuestro trabajo necesite funciones que generamos para hacer nuestro trabajo más simple. Si incluimos el código que define estas funciones en nuestro .Rmd, puede complejizar nuestro código y que sea más dificil de interpretar. Aquí podemos comenzar a incluir archivos secundarios que contengan estas funciones.\nEn las situaciones donde nuestro código no produce resultados, más bien son definiciones de funciones secundarias u otras herramientras, no tiene tanto sentido usar archivos .Rmd. En estos casos podemos volver a los tradicionales scripts.\nSi hipotéticamente quisieramos definir una función que convierte la temperatura en kelvin (algo muy común entre meteorólogos) a la temperatura en grados centígrados tendriamos el siguiente código:\nkelvin_a_centigrados &lt;- function(temperatura) {\n  \n  return(temperatura - 273.15)\n  \n}\nque podríamos guardar en un script de R que se llame funciones_secundarias.R que por supuesto guardaremos en la carpeta “scripts”. Aquí podemos hacer un paréntesis para mencionar la necesidad de documentar apropiadamente cualquier función o código que generemos. Para una función deberíamos incluir:\nAhora el desafío es lograr usar esa función que está en un archivo .R en el reporte .Rmd. Necesitamos cargar el script al comienzo de nuestro archivo para que la función quede disponible para ser utilizada más adelante.\nEl mejor lugar para hacer esto es, en el caso de R Markdown, el bloque de código setup donde además cargamos las librerías que usaremos. Por ejemplo:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#trabajando-con-funciones-y-otro-código",
    "href": "07_funciones.html#trabajando-con-funciones-y-otro-código",
    "title": "\n8  Funciones\n",
    "section": "",
    "text": "Qué hace o cual es su propósito.\nQué argumentos requiere y de que tipo de datos son.\nQué genera cómo resultado.\n\n\nCrea una función\n\nCreá un archivo .R con alguna función. Puede ser la que vimos como ejemplo o alguna otra que prefieras.\nGuardá el archivo en la carpeta scripts\n\n\n\n\nlibrary(ggplo2)\nlibrary(data.table)\nsource(here::here(\"scripts/funciones_secundarias.R\"))\n\nCarga la función\n\nAgrega source(here::here(\"scripts/funciones_secundarias.R\")) al comienzo del archivo .Rmd\nUsa la función en algún bloque de código\nKnitea el archivo para ver el resultado final",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#trabajando-con-datos",
    "href": "07_funciones.html#trabajando-con-datos",
    "title": "\n8  Funciones\n",
    "section": "\n8.2 Trabajando con datos",
    "text": "8.2 Trabajando con datos\nMuchas veces los datos están disponibles en distintos servicios en páginas de internet. Muchos gobiernos por ejemplo, tienen portales de datos abiertos. Organizaciones generan APIs para poner a disposición sus datos o tal vez otras personas publicaron sus datos en servicios como Zenodo y queremos aprovecharlos. Es posible que se puedan decargar los datos visitando la web y haciendo click en un botón, sin embargo podríamos escribir el código necesario para hacer esto de manera programática. Esto hace que nuestro trabajo sea más reproducible y disminuye las chances de error.\nEl código que genera la descarga de datos podría estar incluido en el archivo .Rmd si la descarga no demora. En general querremos incluir la opción de no descargar los datos si el código encuentra que ya fueron descargados previamente. También podríamos generar un script de descarga de datos que corra una sola vez. Esta es una buena idea cuando el código de descarga demora o es complejo.\nVeamos un ejemplo de descarga de datos desde Zenodo.\nSi revisamos la base de datos https://sandbox.zenodo.org/record/1029654 veremos que incluye un solo archivo en formato .csv.\n\n\n\n\n\n\n\n\nVemos también el botón “Download” para la descarga del archivo. Podríamos usarlo para descargar el archivo haciendo click.\nPero como mencionaba previamente, se puede escribir el código necesario para hacer la descarga de manera programática y asegurarnos que tenemos los datos correctos. Podríamos crear una función descarga_pinguinos():\ndescarga_pinguinos &lt;- function() {\n  file &lt;- here::here(\"datos/datos_crudos/penguins.csv\")\n  url &lt;- \"https://sandbox.zenodo.org/record/1029654/files/penguins.csv?download=1\"\n  download.file(url, file)\n}\nPara obtener la dirección url del archivo, hay que hacer click derecho sobre el botón Download y copiar el link.\nAhora si deseas descargar los datos solo hay que llamar a la función descarga_pinguinos() y los datos se guardaran en la carpeta correcta.\nPodríamos mejorar esto generando una función que solo descargue los datos en caso de que no estén presentes en el proyecto. Esta función podría escribirse de esta manera:\ndatos_pinguinos &lt;- function() {\n  file &lt;- here::here(\"datos/datos_crudos/penguins.csv\")\n  if (!file.exists(file)) {\n    descarga_pinguinos()\n  } \n  return(read.csv(file))\n}\nCon esta última función en nuestro archivo .Rmd nos podemos olvidar de la descarga de datos, que se hará automáticamente.\npenguins &lt;- datos_pinguinos()\n\nDescarga de datos programática\n\nSiguiendo los pasos anteriores, general las funciones necesarias para descargar los datos prográtiacamente en la carpeta correcta.\nLas funciones pueden estar al comienzo del archivo o puedes guardarlas en el script funciones_secundarias.R (o un nuevo script) y cargarlas al comienzo.\nPara revisar que todo funciona, knitea el archivo y chequea que los datos estén en la carpeta correcta.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html",
    "href": "09_paquetes-1.html",
    "title": "\n10  Empaquetando funciones\n",
    "section": "",
    "text": "Una mejor opción es crear una ubicación específica para el código que que no es parte del paquete, y asegurarse de que es ignorado cuando el paquete se construye. Hay una función usethis use_directory() que ayuda a configurar esto. esto. Vamos a crear un directorio dev/ en nuestro proyecto de paquete:\n\nuse_directory(\"dev\", ignore = TRUE)\n\n✓ Creating 'dev/'\n✓ Adding '^dev$' to '.Rbuildignore'\nThe argument ignore = TRUE adds this folder to .Rbuildignore - a file that lists things that shouldn’t be included in the package when it is built.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html",
    "href": "A_instalacion.html",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "",
    "text": "Instalando R",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-r",
    "href": "A_instalacion.html#instalando-r",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "",
    "text": "Ubuntu o derivados\nPara tener la última versión, tenés que agregar los repositorios de CRAN. Para hacerlo, vas a tener que tener permisos de administrador. Los detalles están en esta página, pero el resumen es:\nsudo apt update -qq\nsudo apt install --no-install-recommends software-properties-common dirmngr\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\"\nsudo sudo apt install r-base r-base-dev\nSi todo salió bien, tenés que tener instalado R en tu máquina y podés ejecutarlo con el comando R en la consola.\n\n\n\nMac\n\nIr a CRAN: https://cran.r-project.org\nHacer click en el link “Download R for (Mac) OS X”.\nDescarga el paquete correspondiente a tu sistema operativo.\nEjecuta el paquete.\n\nDownload R for Linux (Debian, Fedora/Redhat, Ubuntu) Download R for macOS\n\n\nWindows\n\nEntrá a https://cran.r-project.org/bin/windows/base/ y bajate el instalador haciendo click en el link grandote que dice “Download R x.x.x for Windows”.\nUna vez que se bajó, hacé doble click en el archivo y seguí las instrucciones del instalador.\nUna vez que se termine de instalar, te va a aparecer un ícono como este en el escritorio o en los programas instalados: {{&lt; figure \"r-logo.jpeg\" \"20px\" &gt;}}\nAl ejecutarlo, les tiene que aparecer algo como esto:\n\n\nSi ves una ventana así significa que ya tenés instalado R, pero seguí leyendo! Todavía falta unos pasos para poder sacarle todo el jugo: necesitamos instalar RTools.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-rtools",
    "href": "A_instalacion.html#instalando-rtools",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Instalando RTools",
    "text": "Instalando RTools\nPara instalar algunos paquetes de R en Windows, vas a necesitar instalar un programa adicional llamado rtools.\n\nEntrá a https://cran.r-project.org/bin/windows/Rtools/ y descargate el instalador de version mas nueva, en este momento es Rtools44. Para eso hacer click en Rtools44 y en es nueva pagina hacer clik en Rtools44 installer.\nEjecuta el instalador y segui las instrucciones.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-rstudio",
    "href": "A_instalacion.html#instalando-rstudio",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Instalando RStudio",
    "text": "Instalando RStudio\nIngresa en el sitio web de Posit y descarga RStudio para desktop para tu sistema operativo: https://posit.co/download/rstudio-desktop/\n\nUbuntu o derivados\nSi tenés instalada una interfaz gráfica para instalar archivos .deb, ejecutando el archivo que descargaste ya vas a poder instalar RStudio. Si no, abrí una terminal en el directorio donde bajaste el archivo y ejecutá\nsudo dpkg -i ARCHIVO\nReemplazando ARCHIVO por el nombre del archivo instalador.\nEs posible que salte algún error por falta de alguna dependencia, en ese caso usá\nsudo apt-get -f install\nY debería estar arreglado.\nTerminada la instalacion, al ejecutar RStudio les tiene que aparecer una ventana como esta:\n\n\n\nMac\nLa primera vez que abrimos RStudio nos ofrece instalar las herramientas de XCode para línea de comandos. Aceptamos haciendo clic en instalar.\n\n\nWindows\nComo siempre, doble click en el archivo y seguir los pasos de instalación.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-git",
    "href": "A_instalacion.html#instalando-git",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Instalando Git",
    "text": "Instalando Git\nGit es una herramienta para control de versiones, vamos a utilizarla para trabajar colaborativamente.\nEn la pagina de Git podemos descargar el instalador para nuestro sistema operativo.\nEn esa misma pagina hay una guia de instalacion para cada sistema operativo en castellano. Sigue las instrucciones detallas en la misma.\nUna vez que tengas git instalado y tu cuenta de GitHub hay que conectarlo con RStudio. En particular hay que setear el “token”, una especie de contraseña para poder hacer cambios en GitHub.\nPrimero tendrás que correr el siguente código (tenés que instalar usethis primero)\nusethis::create_github_token()\nSe abrirá la ventana de git y ahí tendrás que seguir los pasos para crear el token y copiarlo (muy importante!).\nAhora corré el siguiente código (necesitas el paquete credentials)\ncredentials::set_github_pat()\nElegí crear/guardar el token.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#crear-cuentas",
    "href": "A_instalacion.html#crear-cuentas",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Crear cuentas",
    "text": "Crear cuentas\n\nCrear una cuenta en GitHub\nGitHub es una de las interfaces y repositorios mundiales mas conocidos y utilizados por quienes desarrollan software. Vamos a utilizarlo para compartir el codigo que vamos a escribir en la materia.\n\nIr a https://github.com/.\nHacer clik en Registrarse or Sign up.\nSeguir las indicaciones para crear la cuenta personal.\nUno de los pasos implica chequear que son una persona y luego validar la direccion de email que usaste para crear la cuenta.\n\n\n\nCrear una cuenta en Posit Cloud\n\nIr a https://posit.cloud/plans/free.\nHacer clik en “Sign Up” y seguir las indicaciones para crear la cuenta personal.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "B_soluciones.html",
    "href": "B_soluciones.html",
    "title": "Appendix B — Soluciones Ejercicios",
    "section": "",
    "text": "Este anexo detalla resultados validos para todos los ejercicios desde el capitulo 1 al 6. Recuerda que pueden existir mas de una manera de resolver los ejercicios de forma correcta.\n\nB.0.1 Capitulo 3 - Lectura de datos\n\nEn el portal de datos de Argentina encontramos muchos conjuntos de datos con informacion oficial. Vamos a descargar y leer un archivo de Excel.\n\nDirigirse a esta pagina web con datos abiertos: https://datos.gob.ar/dataset/produccion-innovacion-productiva-empresas-que-mas-invierten-id-nivel-mundial\nRealizar los pasos necesarios para descargar el archivo de Excel del conjunto de datos “Las 50 empresas más innovadoras entre 2013 y 2019” de forma programatica.\nCargar el conjunto de datos en r y explorar su estructura con la función str().\nContestar:\n\n4.1 ¿Cuántas columnas y filas tiene el data.frame?\n4.2 ¿Qué tipo de dato hay en cada columna? ¿el tipo de dato es correcto según el contenido que vez?\n4.3 ¿Que funcion usaste para leer el archivo de Excel?\nAl final del ejercicio deberías tener un archivo .qmd o .R con el código que lo resuelve. Nombrá el archivo siguiendo los consejos que vimos en clase.\n\n\n# Respuesta\n\n# 1. Descargar el archivo de Excel\n\nurl &lt;- \"https://datos.produccion.gob.ar/dataset/369e2ef5-f8bc-4b37-a3e7-f7ad8d5fceb7/resource/64aa7c24-2adc-46f1-b60d-1d34e2c7dbee/download/las-50-empresas-mas-innovadoras-entre-2013-y-2019.xlsx\"\n\ndownload.file(url, destfile = \"empresas-que-mas-invierten-en-innovacion.xlsx\")\n\n# 2. Leer el archivo de Excel\n\nlibrary(readxl)\n\nempresas &lt;- read_excel(\"empresas-que-mas-invierten-en-innovacion.xlsx\")\n\n# 3. Explorar la estructura del data.frame\n\nstr(empresas)\n\ntibble [50 × 5] (S3: tbl_df/tbl/data.frame)\n $ empresa                          : chr [1:50] \"Volkswagen\" \"Alphabet\" \"Samsung Electronics\" \"Microsoft\" ...\n $ pais_origen                      : chr [1:50] \"Alemania\" \"Estados Unidos\" \"Corea del Sur\" \"Estados Unidos\" ...\n $ sector_productivo                : chr [1:50] \"Automotriz\" \"Tecnología\" \"Bienes y servicios industriales\" \"Tecnología\" ...\n $ inversion_acumulada_2013_2019_EUR: num [1:50] 93228000 92570009 90817382 85723517 75066258 ...\n $ variacion_porcentual_2013_2019   : num [1:50] 21.8 303.8 52.9 107.8 54.6 ...\n\n# 4. Contestar\n\n# 4.1. Tiene 5 columnas y 50 fila\n\n# 4.2. empresa es caracter, pais_origen es caracter, sector_productivo es caracter, inversion_acumulada_2013_2019_EUR es numerico y varion_porcentual_2013_2019 es numerico. Si el tipo de dato es correcto.\n\n# 4.3 Se uso la funcion read_excel() del paquete readxl",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Soluciones Ejercicios</span>"
    ]
  },
  {
    "objectID": "B_soluciones.html#capitulo-4---manipulación-de-datos-ordenados-i",
    "href": "B_soluciones.html#capitulo-4---manipulación-de-datos-ordenados-i",
    "title": "Appendix B — Soluciones Ejercicios",
    "section": "\nB.1 Capitulo 4 - Manipulación de datos ordenados I",
    "text": "B.1 Capitulo 4 - Manipulación de datos ordenados I\n\nEs hora de revisar lo que vimos hasta acá.\n\nDescargá el archivo que se encuentra en este link y guardalo en tu proyecto de trabajo en clase.\nResolvé los ejercicios propuestos de lectura (yapa!) y de filtros. En algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nEl archivo tiene más ejercicios, pero no te adelantes. Vamos a ver esos temas a continuación.\n\n\n\n¿Te acordás del ejercicio que arrancaste cuando vimos filtros? Es hora de completarlo!\n\nCompletá los ejercicios de este archivo que ya deberías tener en tu proyecto.\nTe vas a encontrar con ejercicios para practicar summarise() y mutate(). De nuevo, en algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nCuando hayas terminado, knitea el archivo para generar un html y ver como queda el resultado.\n\n\n\nB.1.1 Soluciones\nEste archivo incluye ejercicios para practicar como manipular datos usando dplyr. Es importante que guardes este archivo en el proyecto de RStudio que usas durante las clases.\nSeguiremos trabajando con los datos de pingüinos.\nSiempre arrancamos cargando las librerías que vamos a usar. Completá el código y corré el bloque de código para comenzar.\n\n# Cargá las librerias necesarias en este bloque de código\n\nlibrary(dplyr)\nlibrary(readr)\n\nEs momento de leer los datos de pingüinos (si, también hay que practicar leer datos).\n\n# Lectura de datos de pinguinos\npinguinos &lt;- read_csv(here::here(\"datos/pinguinos.csv\"))\n\n\nB.1.1.1 Filtrando datos\nCompletá el código y correlo para verificar el resultado.\n¿Cuántos pingüinos tienen aletas de más de 225 mm?\n\npinguinos |&gt; \n  filter(largo_aleta_mm &gt; 225)\n\n¿Algún pingüino tiene un pico de exactamente 40.9 mm?\n\npinguinos |&gt; \n  filter(largo_pico_mm == 40.9)\n\n¿Cuántos pingüinos hembra hay en la especie Papúa?\n\npinguinos |&gt; \n  filter(especie == \"Papúa\", sexo == \"hembra\")\n\n\nB.1.1.2 Resumiendo los datos\n¿Cuántos pingüinos hay en cada isla?\n\npinguinos |&gt; \n  group_by(isla) |&gt; \n  summarise(n())\n\n¿Todas las especies viven en las mismas islas?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(n())\n\n¿Cuánto pesa el pinguino más liviano y el más pesado de cada especie?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(mas_liviano = min(masa_corporal_g, na.rm = TRUE),\n            mas_pesado = max(masa_corporal_g, na.rm = TRUE))\n\n\nB.1.1.3 Transformando variables\nCalculá la relación entre el alto y el largo del pico (alto_pico_mm/largo_pico_mm)\n\npinguinos |&gt; \n  mutate(pico = alto_pico_mm/largo_pico_mm)\n\nTransformá todas las variables de mm a cm.\n\npinguinos |&gt; \n  mutate(largo_pico_cm = largo_pico_mm/10,\n         alto_pico_cm = alto_pico_mm/10,\n         largo_aleta_cm = largo_aleta_mm/10)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Soluciones Ejercicios</span>"
    ]
  },
  {
    "objectID": "B_soluciones.html#filtrando-datos",
    "href": "B_soluciones.html#filtrando-datos",
    "title": "Appendix B — Soluciones Ejercicios",
    "section": "\nB.2 Filtrando datos",
    "text": "B.2 Filtrando datos\nCompletá el código y correlo para verificar el resultado.\n¿Cuántos pingüinos tienen aletas de más de 225 mm?\n\npinguinos |&gt; \n  filter(largo_aleta_mm &gt; 225)\n\n# A tibble: 15 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Papúa   Bisc…          50           16.3            230            5700 macho\n 2 Papúa   Bisc…          59.6         17              230            6050 macho\n 3 Papúa   Bisc…          54.3         15.7            231            5650 macho\n 4 Papúa   Bisc…          49.8         16.8            230            5700 macho\n 5 Papúa   Bisc…          49.5         16.2            229            5800 macho\n 6 Papúa   Bisc…          48.6         16              230            5800 macho\n 7 Papúa   Bisc…          50.8         17.3            228            5600 macho\n 8 Papúa   Bisc…          52.1         17              230            5550 macho\n 9 Papúa   Bisc…          52.2         17.1            228            5400 macho\n10 Papúa   Bisc…          50.8         15.7            226            5200 macho\n11 Papúa   Bisc…          55.9         17              228            5600 macho\n12 Papúa   Bisc…          49.1         15              228            5500 macho\n13 Papúa   Bisc…          49.8         15.9            229            5950 macho\n14 Papúa   Bisc…          51.5         16.3            230            5500 macho\n15 Papúa   Bisc…          55.1         16              230            5850 macho\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\n¿Algún pingüino tiene un pico de exactamente 40.9 mm?\n\npinguinos |&gt; \n  filter(largo_pico_mm == 40.9)\n\n# A tibble: 4 × 8\n  especie isla   largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n1 Adelia  Dream           40.9         18.9            184            3900 macho\n2 Adelia  Torge…          40.9         16.8            191            3700 hemb…\n3 Papúa   Biscoe          40.9         13.7            214            4650 hemb…\n4 Barbijo Dream           40.9         16.6            187            3200 hemb…\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\n¿Cuántos pingüinos hembra hay en la especie Papúa?\n\npinguinos |&gt; \n  filter(especie == \"Papúa\", sexo == \"hembra\")\n\n# A tibble: 58 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Papúa   Bisc…          46.1         13.2            211            4500 hemb…\n 2 Papúa   Bisc…          48.7         14.1            210            4450 hemb…\n 3 Papúa   Bisc…          46.5         13.5            210            4550 hemb…\n 4 Papúa   Bisc…          45.4         14.6            211            4800 hemb…\n 5 Papúa   Bisc…          43.3         13.4            209            4400 hemb…\n 6 Papúa   Bisc…          40.9         13.7            214            4650 hemb…\n 7 Papúa   Bisc…          45.5         13.7            214            4650 hemb…\n 8 Papúa   Bisc…          45.8         14.6            210            4200 hemb…\n 9 Papúa   Bisc…          42           13.5            210            4150 hemb…\n10 Papúa   Bisc…          46.2         14.5            209            4800 hemb…\n# ℹ 48 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Soluciones Ejercicios</span>"
    ]
  },
  {
    "objectID": "B_soluciones.html#resumiendo-los-datos",
    "href": "B_soluciones.html#resumiendo-los-datos",
    "title": "Appendix B — Soluciones Ejercicios",
    "section": "\nB.3 Resumiendo los datos",
    "text": "B.3 Resumiendo los datos\n¿Cuántos pingüinos hay en cada isla?\n\npinguinos |&gt; \n  group_by(isla) |&gt; \n  summarise(n())\n\n# A tibble: 3 × 2\n  isla      `n()`\n  &lt;chr&gt;     &lt;int&gt;\n1 Biscoe      168\n2 Dream       124\n3 Torgersen    52\n\n\n¿Todas las especies viven en las mismas islas?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(n())\n\n`summarise()` has grouped output by 'isla'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 3\n# Groups:   isla [3]\n  isla      especie `n()`\n  &lt;chr&gt;     &lt;chr&gt;   &lt;int&gt;\n1 Biscoe    Adelia     44\n2 Biscoe    Papúa     124\n3 Dream     Adelia     56\n4 Dream     Barbijo    68\n5 Torgersen Adelia     52\n\n\n¿Cuánto pesa el pinguino más liviano y el más pesado de cada especie?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(mas_liviano = min(masa_corporal_g, na.rm = TRUE),\n            mas_pesado = max(masa_corporal_g, na.rm = TRUE))\n\n`summarise()` has grouped output by 'isla'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 4\n# Groups:   isla [3]\n  isla      especie mas_liviano mas_pesado\n  &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;\n1 Biscoe    Adelia         2850       4775\n2 Biscoe    Papúa          3950       6300\n3 Dream     Adelia         2900       4650\n4 Dream     Barbijo        2700       4800\n5 Torgersen Adelia         2900       4700",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Soluciones Ejercicios</span>"
    ]
  },
  {
    "objectID": "B_soluciones.html#transformando-variables",
    "href": "B_soluciones.html#transformando-variables",
    "title": "Appendix B — Soluciones Ejercicios",
    "section": "\nB.4 Transformando variables",
    "text": "B.4 Transformando variables\nCalculá la relación entre el alto y el largo del pico (alto_pico_mm/largo_pico_mm)\n\npinguinos |&gt; \n  mutate(pico = alto_pico_mm/largo_pico_mm)\n\n# A tibble: 344 × 9\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 2 more variables: anio &lt;dbl&gt;, pico &lt;dbl&gt;\n\n\nTransformá todas las variables de mm a cm.\n\npinguinos |&gt; \n  mutate(largo_pico_cm = largo_pico_mm/10,\n         alto_pico_cm = alto_pico_mm/10,\n         largo_aleta_cm = largo_aleta_mm/10)\n\n# A tibble: 344 × 11\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 4 more variables: anio &lt;dbl&gt;, largo_pico_cm &lt;dbl&gt;, alto_pico_cm &lt;dbl&gt;,\n#   largo_aleta_cm &lt;dbl&gt;",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Soluciones Ejercicios</span>"
    ]
  }
]
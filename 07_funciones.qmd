---
title: "Funciones"
---

## Objetivos de aprendizaje

- Convertir un bloque de código R en una función
- Utilizar funciones de otros paquetes en una función de su propio paquete
- Devolver un mensaje de error desde una función


## Trabajando con funciones y otro código

Hasta ahora tenemos un proyecto con una determinada estructura de carpetas que nos permite ordenar nuestro trabajo. Inicialmente escribir el código necesairo para resolver un problema, leer un archivo o calcular medidas estadísticas es lo más razonable. Pero es posible que te encuentres repitiendo las mismas lineas de código o copiado y pegando código de un lado para el otro porque necesitás reutilizar algo que ya escribíste. 

En estas situaciones es una buena idea comenzar a encapsular código en funciones. En esta sección veremos como escribir funciones, más adelante *empaquetaremos* esas funciones en un paquete. 

Escribir funciones tiene tres grandes ventajas sobre copiar y pegar código:

* Podés nombrar tus funciones con un nombre descriptivo que facilite la comprensión del código.
* Si por alguna razón tenés que cambiar el código, sólo es necesitás hacerlo en un único lugar.
* Eliminás la posibilidad de cometer errores al copiar y pegar código.

En las situaciones donde nuestro código no produce resultados, más bien son definiciones de funciones secundarias u otras herramientras, no tiene tanto sentido usar archivos .Rmd o .qmd. En estos casos podemos volver a los tradicionales scripts (.R).

## Esqueleto de una función

Cualquier función en R tendrá la siguiente pinta (se le llama firma de una función):

```r
nombre_de_funcion <- function(arg1, arg2, ...) {
# código que hace algo 
}
```
Como habrás notado necesitamos la función `function()` para crear una función. Hay tres pasos clave para crear una nueva función:

* Tenés que elegir un nombre para la función.
* Enumeras los argumentos, los elementos de entrada que necesita el código para correr, en el ejemplo `arg1`, `arg2`, `...`.
* Colocas el código que has desarrollado en el cuerpo de la función, un bloque entre `{}` inmediatamente después de `function(...)`.

Imaginemos que tenemos este código:

```{r}
temperatura_ayer <- 53.6 # en Fahrenheit!

temperatura_ayer_c <- (temperatura_ayer - 32) * 5/9 # convierto a centigrados
```

De nuevo, este código no va a ser útil si querés usarlo en otro lugares, necesitamos generalizarlo en una función. 

El primer paso es pensar un nombre, por ejemplo `fahrenheit_a_centigrados`. Luego tenemos que analizar el código e identificar cuales son los argumentos, la información que necesita la función, en este caso la temperatura en Fahrenheit, es es un argumento. 

```{r}
fahrenheit_a_centigrados <- function(temperatura_ayer) {
  (temperatura_ayer - 32) * 5/9
}
```

Está función está lista para usar, por ejemplo podemos convertir 100 Fahrenheit a centigrados:

```{r}
fahrenheit_a_centigrados(100)
```

Si bien podemos nombrar a los argumentos de las funciones de cualquier manera, `temperatura_ayer` no es razonable para una función general. Un mejor nombre podría ser `temperatura_fahrenheit`

```{r}
fahrenheit_a_centigrados <- function(temperatura_fahrenheit) {
  (temperatura_fahrenheit - 32) * 5/9
}
```

Es posible que te encuentres con algo del estilo:

```{r}
fahrenheit_a_centigrados <- function(temperatura_fahrenheit) {
  resultado <- (temperatura_fahrenheit - 32) * 5/9
  return(temperatura_centigrados)
}
```

Usar la función `return()` no es necesario, R devuelve el último elemento con o sin el `return()` presente. Sin embargo, puede ayudar a la lectura del código cuando la función es más compleja.

::: informacion

Notá además que cuando corrimos la función anterior, en ningún momento se creó la variable `resultado`, si revisas el Environment no la vas a encontrar. Eso es así porque todo lo que ocurre adentro de la función, se queda adentro de la función. El código corre en un "ambiente" independiente de el ambiente general. 
:::

Aquí podemos hacer un paréntesis para mencionar la necesidad de documentar apropiadamente cualquier función o código que generemos. Para una función deberíamos incluir:

-   Qué hace o cual es su propósito.

-   Qué argumentos requiere y de que tipo de datos son.

-   Qué genera cómo resultado.

::: ejercicio

1.  Creá un archivo .R con alguna función. Puede ser la que vimos como ejemplo o alguna otra que prefieras.
2.  Guardá el archivo con un nombre informativo.
3.  Al comienzo del archivo, en comentarios, incluí que hace la función, que argumentos requiere y que genera.
:::

Ahora si quisieramos usar esa función en el análisis, podemos "cargarla" con `source("archivo.R")`.

La escritura de una función debería arrancar con un código que ya funciona. Es decir, en lugar de
empezar desde cero `fahrenheit_a_centigrados()` usamos el código que ya tenemos y que funciona para un ejemplo particular. Luego cambiando el nombre del argumento podemos generalizar el código. 
## Testeá tu función

Es importante que pruebes tu función de distintas maneras. Primero, con algún valor para el que sabes el resultado, por ejemplo 32 fahrenheit es 0º centigrados.

```{r}
fahrenheit_a_centigrados(32)
```

También es importante testear la función con datos diferentes, por ejemplo en vez de 1 número entero, podemos usar un real o un vector de números.

```{r}
fahrenheit_a_centigrados(25.5)
```

```{r}
fahrenheit_a_centigrados(c(0, 32, 100))
```

Hay que chequear si estos resultados son correctos. ¿Esperabas obtener 3 valores en el segundo último ejemplo? ¿tiene sentido que haga esto?

Finalmente, tenemos que probar la función con otras cosas. 

```{r}
fahrenheit_a_centigrados("100")
```

```{r}
fahrenheit_a_centigrados(TRUE)
```

El primero ejemplo da un error, poco informativo pero un error al fin. El segundo ejemplo devuelve un resultado, pero ¿no debería dar error? 

Por estas situaciones es importante chequear que lo que ingresa a la función es lo esperado, antes de hacer ninguna otra operación. 

### Revisá que los argumentos sean válidos

El primer acercamiento a esto es la función `stopifnot()`

```{r}
fahrenheit_a_centigrados <- function(temperatura_centigrados) {
  
  stopifnot(is.numeric(temperatura_centigrados))
  
  (temperatura_centigrados - 32) * 5/9
}
```

Ahora si volvemos a correr algunos de los ejemplos previos, obtendremos:

```{r}
fahrenheit_a_centigrados("100")
```

Pero de nuevo, esta función no devuelve un mensaje muy informativo.

La siguiente solución implica encapsular la función `stop()` en una estructura `if` para poder incluir un mensaje de error apropiado:

```{r}
fahrenheit_a_centigrados <- function(temperatura_centigrados) {
  
  if (!is.numeric(temperatura_centigrados)) {
    stop("temperatura_centigrados debe ser numérico,\n",
         "La variable ingresada es un ", class(temperatura_centigrados)[1])
  }
  
  (temperatura_centigrados - 32) * 5/9
}
```

```{r}
fahrenheit_a_centigrados("100")
```

Este mensaje nos da mucha más información:

* En que función ocurre el error
* La causa del error y como resolverlo.

Pero hay otras soluciones aún  más superadoras, podemos escribir mensajes de error y warnings (advertencias en inglés) usando el paquete `cli`:

```{r}
fahrenheit_a_centigrados <- function(temperatura_centigrados) {
  
  if (!is.numeric(temperatura_centigrados)) {
    cli::cli_abort(c(
      "temperatura_centigrados debe ser numérico.",
      "i" =  "La variable ingresada es un {class(temperatura_centigrados)[1]}."
    ))
  }
  
  (temperatura_centigrados - 32) * 5/9
}
```


```{r}
fahrenheit_a_centigrados("100")
```

El mensaje de error se ve mejor y nos permite organizar la información. En este caso usamos `cli_abort()` pero hay toda una familia de funciones según la circusntancia, por ejemplo si queremos mostrar un warning, si la función corrió con exito, etc.

Además podemos mostrar distintos tipos de mensajes:

```{r}
cli::cli_bullets(c(
  "noindent",
  " " = "indent",
  "*" = "bullet",
  ">" = "arrow",
  "v" = "success",
  "x" = "danger",
  "!" = "warning",
  "i" = "info"
))
```

::: ejercicio

Escribí una función para descargar y leer los datos de pingüinos. 

1. La función debe aceptar un argumento, la ruta al archivo en tu computadora.
2. Revisá si el archivo ya existe en esa ruta, usá la función `file.exist()`.
* Si el archivo no está descargado, el código debe descargarlo y luego leerlo.
* Si el archivo ya está descargado, el código debe leerlo. 
3. Agrega mensajes con `cli_inform()` para que el usuario sepa lo que  la función hizo. 

```{r eval=FALSE, include=FALSE}

descarga_pinguinos <- function(ruta_archivo) {
  file <- here::here(ruta_archivo)
  url <- "https://zenodo.org/records/12772944/files/pinguinos.csv?download=1"
  download.file(url, file)
}

datos_pinguinos <- function(ruta_archivo) {
  file <- here::here(ruta_archivo)
  if (!file.exists(file)) {
    descarga_pinguinos(ruta_archivo)
    cli::cli_inform(c("v" = "Descargado el archivo en {ruta_archivo}"))
  } 
  cli::cli_inform(c("v" = "Leyendo los datos"))
  return(read.csv(file))
}

penguins <- datos_pinguinos("datos/datos_pinguinos.csv")

```

::: 

## Escribí funciones para humanos y computadoras

Es importante recordar que las funciones no son sólo para las entienda R, sino también para los humanos. A R no le importa cómo se llama tu función, o qué comentarios contiene, pero éstos son importantes para que vos y otras personas entiendan lo que hace. 

El nombre de una función es importante. Lo ideal es que el nombre de tu función sea corto, pero que describa claramente lo que hace la función. Eso es difícil. Pero es mejor que el nombre sea claro a que sea muy corto. También que ayude a RStudio a autocompletar.

Generalmente, los nombres de las funciones son verbos, y los argumentos sustantivos.Esto es porque las funciones *hacen* algo, tienen una acción asociada. Por supuesto, hay excepciones a la regla. Los sustantivos como nombre de funciones están bien si la función calcula un sustantivo muy conocido (por ejemplo, `promedio()` es mejor que `calcula_promedio()`), o accede a alguna propiedad de un objeto (por ejemplo, `coef()` es mejor que `extraer_coeficientes()`). Una buena señal de que un sustantivo puede ser una mejor opción es si se utiliza un verbo muy amplio como «obtener», «computar», «calcular» o «determinar». Usa tu mejor criterio y no tengas miedo de cambiar el nombre de una función si más adelante se te ocurre uno mejor.

**Muy corto**

* `f()`

**No es un verbo y no es descriptivo**

* `funcion_hermosa()`

**Nombre largo pero claro**

* `computa_faltantes()`
* `colapsa_anios()`

Si el nombre de tu función está compuesto por varias palabras, te recomendamos utlizar «snake_case», donde cada palabra en minúscula está separada por un guión bajo. camelCase es otra buena alternativa. Lo importante es ser coherente: elegí una y no cambies.

Para ayudar a RStudio a autocompletar el nombre de las funciones es mejor esto:


* `input_select()`
* `input_checkbox()`
* `input_text()`

que esto:

* `select_input()`
* `checkbox_input()`
* `text_input()`

### Construyendo un paquete de R paso a paso {#ex-lectura}

::: ejercicio

Agregar 2 o 3 funciones que se puedan generar usando los ejercicios de dplyr
:::
